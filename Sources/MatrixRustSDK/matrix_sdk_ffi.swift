// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    uniffiCheckFfiVersionMismatch()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol AuthenticationServiceProtocol {
    func `configureHomeserver`(`serverNameOrHomeserverUrl`: String)  throws
    func `homeserverDetails`()   -> HomeserverLoginDetails?
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?)  throws -> Client
    func `restoreWithAccessToken`(`token`: String, `deviceId`: String)  throws -> Client

}

public class AuthenticationService: AuthenticationServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`basePath`: String, `passphrase`: String?, `customSlidingSyncProxy`: String?)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_authenticationservice_new(
        FfiConverterString.lower(`basePath`),
        FfiConverterOptionString.lower(`passphrase`),
        FfiConverterOptionString.lower(`customSlidingSyncProxy`), $0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_authenticationservice(pointer, $0) }
    }






    public func `configureHomeserver`(`serverNameOrHomeserverUrl`: String) throws {
        try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_configure_homeserver(self.pointer,
        FfiConverterString.lower(`serverNameOrHomeserverUrl`), $0
    )
}
    }

    public func `homeserverDetails`()  -> HomeserverLoginDetails? {
        return try!  FfiConverterOptionTypeHomeserverLoginDetails.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_homeserver_details(self.pointer, $0
    )
}
        )
    }

    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_login(self.pointer,
        FfiConverterString.lower(`username`),
        FfiConverterString.lower(`password`),
        FfiConverterOptionString.lower(`initialDeviceName`),
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
        )
    }

    public func `restoreWithAccessToken`(`token`: String, `deviceId`: String) throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeAuthenticationError.self) {
    uniffi_matrix_sdk_ffi_fn_method_authenticationservice_restore_with_access_token(self.pointer,
        FfiConverterString.lower(`token`),
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeAuthenticationService: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticationService

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticationService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
        return AuthenticationService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAuthenticationService_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticationService {
    return try FfiConverterTypeAuthenticationService.lift(pointer)
}

public func FfiConverterTypeAuthenticationService_lower(_ value: AuthenticationService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticationService.lower(value)
}


public protocol ClientProtocol {
    func `accountData`(`eventType`: String)  throws -> String?
    func `avatarUrl`()  throws -> String?
    func `cachedAvatarUrl`()  throws -> String?
    func `createRoom`(`request`: CreateRoomParameters)  throws -> String
    func `deviceId`()  throws -> String
    func `displayName`()  throws -> String
    func `getDmRoom`(`userId`: String)  throws -> Room?
    func `getMediaContent`(`mediaSource`: MediaSource)  throws -> [UInt8]
    func `getMediaFile`(`mediaSource`: MediaSource, `body`: String?, `mimeType`: String)  throws -> MediaFileHandle
    func `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: UInt64, `height`: UInt64)  throws -> [UInt8]
    func `getNotificationItem`(`roomId`: String, `eventId`: String)  throws -> NotificationItem
    func `getProfile`(`userId`: String)  throws -> UserProfile
    func `getSessionVerificationController`()  throws -> SessionVerificationController
    func `homeserver`()   -> String
    func `ignoreUser`(`userId`: String)  throws
    func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?)  throws
    func `logout`()  throws
    func `restoreSession`(`session`: Session)  throws
    func `rooms`()   -> [Room]
    func `searchUsers`(`searchTerm`: String, `limit`: UInt64)  throws -> SearchUsersResults
    func `session`()  throws -> Session
    func `setAccountData`(`eventType`: String, `content`: String)  throws
    func `setDelegate`(`delegate`: ClientDelegate?)
    func `setDisplayName`(`name`: String)  throws
    func `setNotificationDelegate`(`notificationDelegate`: NotificationDelegate?)
    func `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: String, `deviceDisplayName`: String, `profileTag`: String?, `lang`: String)  throws
    func `slidingSync`()   -> SlidingSyncBuilder
    func `unignoreUser`(`userId`: String)  throws
    func `uploadMedia`(`mimeType`: String, `data`: [UInt8])  throws -> String
    func `userId`()  throws -> String

}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_client(pointer, $0) }
    }






    public func `accountData`(`eventType`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_account_data(self.pointer,
        FfiConverterString.lower(`eventType`), $0
    )
}
        )
    }

    public func `avatarUrl`() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func `cachedAvatarUrl`() throws -> String? {
        return try  FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func `createRoom`(`request`: CreateRoomParameters) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_create_room(self.pointer,
        FfiConverterTypeCreateRoomParameters.lower(`request`), $0
    )
}
        )
    }

    public func `deviceId`() throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_device_id(self.pointer, $0
    )
}
        )
    }

    public func `displayName`() throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_display_name(self.pointer, $0
    )
}
        )
    }

    public func `getDmRoom`(`userId`: String) throws -> Room? {
        return try  FfiConverterOptionTypeRoom.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `getMediaContent`(`mediaSource`: MediaSource) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(self.pointer,
        FfiConverterTypeMediaSource.lower(`mediaSource`), $0
    )
}
        )
    }

    public func `getMediaFile`(`mediaSource`: MediaSource, `body`: String?, `mimeType`: String) throws -> MediaFileHandle {
        return try  FfiConverterTypeMediaFileHandle.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(self.pointer,
        FfiConverterTypeMediaSource.lower(`mediaSource`),
        FfiConverterOptionString.lower(`body`),
        FfiConverterString.lower(`mimeType`), $0
    )
}
        )
    }

    public func `getMediaThumbnail`(`mediaSource`: MediaSource, `width`: UInt64, `height`: UInt64) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(self.pointer,
        FfiConverterTypeMediaSource.lower(`mediaSource`),
        FfiConverterUInt64.lower(`width`),
        FfiConverterUInt64.lower(`height`), $0
    )
}
        )
    }

    public func `getNotificationItem`(`roomId`: String, `eventId`: String) throws -> NotificationItem {
        return try  FfiConverterTypeNotificationItem.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_notification_item(self.pointer,
        FfiConverterString.lower(`roomId`),
        FfiConverterString.lower(`eventId`), $0
    )
}
        )
    }

    public func `getProfile`(`userId`: String) throws -> UserProfile {
        return try  FfiConverterTypeUserProfile.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_profile(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `getSessionVerificationController`() throws -> SessionVerificationController {
        return try  FfiConverterTypeSessionVerificationController.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(self.pointer, $0
    )
}
        )
    }

    public func `homeserver`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_client_homeserver(self.pointer, $0
    )
}
        )
    }

    public func `ignoreUser`(`userId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `login`(`username`: String, `password`: String, `initialDeviceName`: String?, `deviceId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_login(self.pointer,
        FfiConverterString.lower(`username`),
        FfiConverterString.lower(`password`),
        FfiConverterOptionString.lower(`initialDeviceName`),
        FfiConverterOptionString.lower(`deviceId`), $0
    )
}
    }

    public func `logout`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_logout(self.pointer, $0
    )
}
    }

    public func `restoreSession`(`session`: Session) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_restore_session(self.pointer,
        FfiConverterTypeSession.lower(`session`), $0
    )
}
    }

    public func `rooms`()  -> [Room] {
        return try!  FfiConverterSequenceTypeRoom.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_client_rooms(self.pointer, $0
    )
}
        )
    }

    public func `searchUsers`(`searchTerm`: String, `limit`: UInt64) throws -> SearchUsersResults {
        return try  FfiConverterTypeSearchUsersResults.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_search_users(self.pointer,
        FfiConverterString.lower(`searchTerm`),
        FfiConverterUInt64.lower(`limit`), $0
    )
}
        )
    }

    public func `session`() throws -> Session {
        return try  FfiConverterTypeSession.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_session(self.pointer, $0
    )
}
        )
    }

    public func `setAccountData`(`eventType`: String, `content`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(self.pointer,
        FfiConverterString.lower(`eventType`),
        FfiConverterString.lower(`content`), $0
    )
}
    }

    public func `setDelegate`(`delegate`: ClientDelegate?)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(self.pointer,
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(`delegate`), $0
    )
}
    }

    public func `setDisplayName`(`name`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(self.pointer,
        FfiConverterString.lower(`name`), $0
    )
}
    }

    public func `setNotificationDelegate`(`notificationDelegate`: NotificationDelegate?)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_client_set_notification_delegate(self.pointer,
        FfiConverterOptionCallbackInterfaceNotificationDelegate.lower(`notificationDelegate`), $0
    )
}
    }

    public func `setPusher`(`identifiers`: PusherIdentifiers, `kind`: PusherKind, `appDisplayName`: String, `deviceDisplayName`: String, `profileTag`: String?, `lang`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(self.pointer,
        FfiConverterTypePusherIdentifiers.lower(`identifiers`),
        FfiConverterTypePusherKind.lower(`kind`),
        FfiConverterString.lower(`appDisplayName`),
        FfiConverterString.lower(`deviceDisplayName`),
        FfiConverterOptionString.lower(`profileTag`),
        FfiConverterString.lower(`lang`), $0
    )
}
    }

    public func `slidingSync`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync(self.pointer, $0
    )
}
        )
    }

    public func `unignoreUser`(`userId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `uploadMedia`(`mimeType`: String, `data`: [UInt8]) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_upload_media(self.pointer,
        FfiConverterString.lower(`mimeType`),
        FfiConverterSequenceUInt8.lower(`data`), $0
    )
}
        )
    }

    public func `userId`() throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public protocol ClientBuilderProtocol {
    func `basePath`(`path`: String)   -> ClientBuilder
    func `build`()  throws -> Client
    func `homeserverUrl`(`url`: String)   -> ClientBuilder
    func `passphrase`(`passphrase`: String?)   -> ClientBuilder
    func `serverName`(`serverName`: String)   -> ClientBuilder
    func `serverVersions`(`versions`: [String])   -> ClientBuilder
    func `slidingSyncProxy`(`slidingSyncProxy`: String?)   -> ClientBuilder
    func `username`(`username`: String)   -> ClientBuilder
    func `userAgent`(`userAgent`: String)   -> ClientBuilder

}

public class ClientBuilder: ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }






    public func `basePath`(`path`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_base_path(self.pointer,
        FfiConverterString.lower(`path`), $0
    )
}
        )
    }

    public func `build`() throws -> Client {
        return try  FfiConverterTypeClient.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(self.pointer, $0
    )
}
        )
    }

    public func `homeserverUrl`(`url`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(self.pointer,
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }

    public func `passphrase`(`passphrase`: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_passphrase(self.pointer,
        FfiConverterOptionString.lower(`passphrase`), $0
    )
}
        )
    }

    public func `serverName`(`serverName`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(self.pointer,
        FfiConverterString.lower(`serverName`), $0
    )
}
        )
    }

    public func `serverVersions`(`versions`: [String])  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_versions(self.pointer,
        FfiConverterSequenceString.lower(`versions`), $0
    )
}
        )
    }

    public func `slidingSyncProxy`(`slidingSyncProxy`: String?)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_proxy(self.pointer,
        FfiConverterOptionString.lower(`slidingSyncProxy`), $0
    )
}
        )
    }

    public func `username`(`username`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(self.pointer,
        FfiConverterString.lower(`username`), $0
    )
}
        )
    }

    public func `userAgent`(`userAgent`: String)  -> ClientBuilder {
        return try!  FfiConverterTypeClientBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(self.pointer,
        FfiConverterString.lower(`userAgent`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}


public protocol EventTimelineItemProtocol {
    func `content`()   -> TimelineItemContent
    func `debugInfo`()   -> EventTimelineItemDebugInfo
    func `eventId`()   -> String?
    func `isEditable`()   -> Bool
    func `isLocal`()   -> Bool
    func `isOwn`()   -> Bool
    func `isRemote`()   -> Bool
    func `localSendState`()   -> EventSendState?
    func `reactions`()   -> [Reaction]
    func `readReceipts`()   -> [String: Receipt]
    func `sender`()   -> String
    func `senderProfile`()   -> ProfileDetails
    func `timestamp`()   -> UInt64
    func `uniqueIdentifier`()   -> String

}

public class EventTimelineItem: EventTimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_eventtimelineitem(pointer, $0) }
    }






    public func `content`()  -> TimelineItemContent {
        return try!  FfiConverterTypeTimelineItemContent.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_content(self.pointer, $0
    )
}
        )
    }

    public func `debugInfo`()  -> EventTimelineItemDebugInfo {
        return try!  FfiConverterTypeEventTimelineItemDebugInfo.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_debug_info(self.pointer, $0
    )
}
        )
    }

    public func `eventId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_event_id(self.pointer, $0
    )
}
        )
    }

    public func `isEditable`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_editable(self.pointer, $0
    )
}
        )
    }

    public func `isLocal`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_local(self.pointer, $0
    )
}
        )
    }

    public func `isOwn`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_own(self.pointer, $0
    )
}
        )
    }

    public func `isRemote`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_is_remote(self.pointer, $0
    )
}
        )
    }

    public func `localSendState`()  -> EventSendState? {
        return try!  FfiConverterOptionTypeEventSendState.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_local_send_state(self.pointer, $0
    )
}
        )
    }

    public func `reactions`()  -> [Reaction] {
        return try!  FfiConverterSequenceTypeReaction.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_reactions(self.pointer, $0
    )
}
        )
    }

    public func `readReceipts`()  -> [String: Receipt] {
        return try!  FfiConverterDictionaryStringTypeReceipt.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_read_receipts(self.pointer, $0
    )
}
        )
    }

    public func `sender`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender(self.pointer, $0
    )
}
        )
    }

    public func `senderProfile`()  -> ProfileDetails {
        return try!  FfiConverterTypeProfileDetails.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_sender_profile(self.pointer, $0
    )
}
        )
    }

    public func `timestamp`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_timestamp(self.pointer, $0
    )
}
        )
    }

    public func `uniqueIdentifier`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_eventtimelineitem_unique_identifier(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeEventTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
        return EventTimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEventTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventTimelineItem {
    return try FfiConverterTypeEventTimelineItem.lift(pointer)
}

public func FfiConverterTypeEventTimelineItem_lower(_ value: EventTimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventTimelineItem.lower(value)
}


public protocol HomeserverLoginDetailsProtocol {
    func `authenticationIssuer`()   -> String?
    func `supportsPasswordLogin`()   -> Bool
    func `url`()   -> String

}

public class HomeserverLoginDetails: HomeserverLoginDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(pointer, $0) }
    }






    public func `authenticationIssuer`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_authentication_issuer(self.pointer, $0
    )
}
        )
    }

    public func `supportsPasswordLogin`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(self.pointer, $0
    )
}
        )
    }

    public func `url`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeserverLoginDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeHomeserverLoginDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeserverLoginDetails {
    return try FfiConverterTypeHomeserverLoginDetails.lift(pointer)
}

public func FfiConverterTypeHomeserverLoginDetails_lower(_ value: HomeserverLoginDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeserverLoginDetails.lower(value)
}


public protocol MediaFileHandleProtocol {
    func `path`()   -> String

}

public class MediaFileHandle: MediaFileHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(pointer, $0) }
    }






    public func `path`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMediaFileHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaFileHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaFileHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaFileHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
        return MediaFileHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaFileHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaFileHandle {
    return try FfiConverterTypeMediaFileHandle.lift(pointer)
}

public func FfiConverterTypeMediaFileHandle_lower(_ value: MediaFileHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaFileHandle.lower(value)
}


public protocol MediaSourceProtocol {
    func `toJson`()   -> String
    func `url`()   -> String

}

public class MediaSource: MediaSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediasource(pointer, $0) }
    }



    public static func `fromJson`(`json`: String) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        FfiConverterString.lower(`json`), $0)
})
    }






    public func `toJson`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(self.pointer, $0
    )
}
        )
    }

    public func `url`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_mediasource_url(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMediaSource: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MediaSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
        return MediaSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMediaSource_lift(_ pointer: UnsafeMutableRawPointer) throws -> MediaSource {
    return try FfiConverterTypeMediaSource.lift(pointer)
}

public func FfiConverterTypeMediaSource_lower(_ value: MediaSource) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMediaSource.lower(value)
}


public protocol MessageProtocol {
    func `body`()   -> String
    func `inReplyTo`()   -> InReplyToDetails?
    func `isEdited`()   -> Bool
    func `msgtype`()   -> MessageType?

}

public class Message: MessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_message(pointer, $0) }
    }






    public func `body`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_message_body(self.pointer, $0
    )
}
        )
    }

    public func `inReplyTo`()  -> InReplyToDetails? {
        return try!  FfiConverterOptionTypeInReplyToDetails.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_message_in_reply_to(self.pointer, $0
    )
}
        )
    }

    public func `isEdited`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_message_is_edited(self.pointer, $0
    )
}
        )
    }

    public func `msgtype`()  -> MessageType? {
        return try!  FfiConverterOptionTypeMessageType.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_message_msgtype(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeMessage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
        return Message(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Message) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Message {
    return try FfiConverterTypeMessage.lift(pointer)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMessage.lower(value)
}


public protocol RoomProtocol {
    func `acceptInvitation`()  throws
    func `activeMembersCount`()   -> UInt64
    func `addTimelineListener`(`listener`: TimelineListener)   -> [TimelineItem]
    func `alternativeAliases`()   -> [String]
    func `avatarUrl`()   -> String?
    func `canonicalAlias`()   -> String?
    func `displayName`()  throws -> String
    func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?)  throws
    func `fetchDetailsForEvent`(`eventId`: String)  throws
    func `fetchMembers`()
    func `id`()   -> String
    func `ignoreUser`(`userId`: String)  throws
    func `invitedMembersCount`()   -> UInt64
    func `inviter`()   -> RoomMember?
    func `inviteUserById`(`userId`: String)  throws
    func `isDirect`()   -> Bool
    func `isEncrypted`()  throws -> Bool
    func `isPublic`()   -> Bool
    func `isSpace`()   -> Bool
    func `isTombstoned`()   -> Bool
    func `joinedMembersCount`()   -> UInt64
    func `leave`()  throws
    func `member`(`userId`: String)  throws -> RoomMember
    func `members`()  throws -> [RoomMember]
    func `membership`()   -> Membership
    func `memberAvatarUrl`(`userId`: String)  throws -> String?
    func `memberDisplayName`(`userId`: String)  throws -> String?
    func `name`()   -> String?
    func `paginateBackwards`(`opts`: PaginationOptions)  throws
    func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?)  throws
    func `rejectInvitation`()  throws
    func `removeAvatar`()  throws
    func `removeTimeline`()
    func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?)  throws
    func `retryDecryption`(`sessionIds`: [String])
    func `send`(`msg`: RoomMessageEventContent, `txnId`: String?)
    func `sendAudio`(`url`: String, `audioInfo`: AudioInfo)  throws
    func `sendFile`(`url`: String, `fileInfo`: FileInfo)  throws
    func `sendImage`(`url`: String, `thumbnailUrl`: String, `imageInfo`: ImageInfo)  throws
    func `sendReaction`(`eventId`: String, `key`: String)  throws
    func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?)  throws
    func `sendReadReceipt`(`eventId`: String)  throws
    func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?)  throws
    func `sendVideo`(`url`: String, `thumbnailUrl`: String, `videoInfo`: VideoInfo)  throws
    func `setName`(`name`: String?)  throws
    func `setTopic`(`topic`: String)  throws
    func `topic`()   -> String?
    func `uploadAvatar`(`mimeType`: String, `data`: [UInt8])  throws

}

public class Room: RoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_room(pointer, $0) }
    }






    public func `acceptInvitation`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_accept_invitation(self.pointer, $0
    )
}
    }

    public func `activeMembersCount`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(self.pointer, $0
    )
}
        )
    }

    public func `addTimelineListener`(`listener`: TimelineListener)  -> [TimelineItem] {
        return try!  FfiConverterSequenceTypeTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_add_timeline_listener(self.pointer,
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }

    public func `alternativeAliases`()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(self.pointer, $0
    )
}
        )
    }

    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func `canonicalAlias`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(self.pointer, $0
    )
}
        )
    }

    public func `displayName`() throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_display_name(self.pointer, $0
    )
}
        )
    }

    public func `edit`(`newMsg`: String, `originalEventId`: String, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_edit(self.pointer,
        FfiConverterString.lower(`newMsg`),
        FfiConverterString.lower(`originalEventId`),
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `fetchDetailsForEvent`(`eventId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_fetch_details_for_event(self.pointer,
        FfiConverterString.lower(`eventId`), $0
    )
}
    }

    public func `fetchMembers`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_fetch_members(self.pointer, $0
    )
}
    }

    public func `id`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_id(self.pointer, $0
    )
}
        )
    }

    public func `ignoreUser`(`userId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `invitedMembersCount`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(self.pointer, $0
    )
}
        )
    }

    public func `inviter`()  -> RoomMember? {
        return try!  FfiConverterOptionTypeRoomMember.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_inviter(self.pointer, $0
    )
}
        )
    }

    public func `inviteUserById`(`userId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
    }

    public func `isDirect`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_is_direct(self.pointer, $0
    )
}
        )
    }

    public func `isEncrypted`() throws -> Bool {
        return try  FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(self.pointer, $0
    )
}
        )
    }

    public func `isPublic`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_is_public(self.pointer, $0
    )
}
        )
    }

    public func `isSpace`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_is_space(self.pointer, $0
    )
}
        )
    }

    public func `isTombstoned`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(self.pointer, $0
    )
}
        )
    }

    public func `joinedMembersCount`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(self.pointer, $0
    )
}
        )
    }

    public func `leave`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_leave(self.pointer, $0
    )
}
    }

    public func `member`(`userId`: String) throws -> RoomMember {
        return try  FfiConverterTypeRoomMember.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_member(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `members`() throws -> [RoomMember] {
        return try  FfiConverterSequenceTypeRoomMember.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_members(self.pointer, $0
    )
}
        )
    }

    public func `membership`()  -> Membership {
        return try!  FfiConverterTypeMembership.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_membership(self.pointer, $0
    )
}
        )
    }

    public func `memberAvatarUrl`(`userId`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `memberDisplayName`(`userId`: String) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(self.pointer,
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `name`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_name(self.pointer, $0
    )
}
        )
    }

    public func `paginateBackwards`(`opts`: PaginationOptions) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_paginate_backwards(self.pointer,
        FfiConverterTypePaginationOptions.lower(`opts`), $0
    )
}
    }

    public func `redact`(`eventId`: String, `reason`: String?, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_redact(self.pointer,
        FfiConverterString.lower(`eventId`),
        FfiConverterOptionString.lower(`reason`),
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `rejectInvitation`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_reject_invitation(self.pointer, $0
    )
}
    }

    public func `removeAvatar`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(self.pointer, $0
    )
}
    }

    public func `removeTimeline`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_remove_timeline(self.pointer, $0
    )
}
    }

    public func `reportContent`(`eventId`: String, `score`: Int32?, `reason`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_report_content(self.pointer,
        FfiConverterString.lower(`eventId`),
        FfiConverterOptionInt32.lower(`score`),
        FfiConverterOptionString.lower(`reason`), $0
    )
}
    }

    public func `retryDecryption`(`sessionIds`: [String])  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_retry_decryption(self.pointer,
        FfiConverterSequenceString.lower(`sessionIds`), $0
    )
}
    }

    public func `send`(`msg`: RoomMessageEventContent, `txnId`: String?)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_send(self.pointer,
        FfiConverterTypeRoomMessageEventContent.lower(`msg`),
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `sendAudio`(`url`: String, `audioInfo`: AudioInfo) throws {
        try
    rustCallWithError(FfiConverterTypeRoomError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_audio(self.pointer,
        FfiConverterString.lower(`url`),
        FfiConverterTypeAudioInfo.lower(`audioInfo`), $0
    )
}
    }

    public func `sendFile`(`url`: String, `fileInfo`: FileInfo) throws {
        try
    rustCallWithError(FfiConverterTypeRoomError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_file(self.pointer,
        FfiConverterString.lower(`url`),
        FfiConverterTypeFileInfo.lower(`fileInfo`), $0
    )
}
    }

    public func `sendImage`(`url`: String, `thumbnailUrl`: String, `imageInfo`: ImageInfo) throws {
        try
    rustCallWithError(FfiConverterTypeRoomError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_image(self.pointer,
        FfiConverterString.lower(`url`),
        FfiConverterString.lower(`thumbnailUrl`),
        FfiConverterTypeImageInfo.lower(`imageInfo`), $0
    )
}
    }

    public func `sendReaction`(`eventId`: String, `key`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_reaction(self.pointer,
        FfiConverterString.lower(`eventId`),
        FfiConverterString.lower(`key`), $0
    )
}
    }

    public func `sendReadMarker`(`fullyReadEventId`: String, `readReceiptEventId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_read_marker(self.pointer,
        FfiConverterString.lower(`fullyReadEventId`),
        FfiConverterOptionString.lower(`readReceiptEventId`), $0
    )
}
    }

    public func `sendReadReceipt`(`eventId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_read_receipt(self.pointer,
        FfiConverterString.lower(`eventId`), $0
    )
}
    }

    public func `sendReply`(`msg`: String, `inReplyToEventId`: String, `txnId`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_reply(self.pointer,
        FfiConverterString.lower(`msg`),
        FfiConverterString.lower(`inReplyToEventId`),
        FfiConverterOptionString.lower(`txnId`), $0
    )
}
    }

    public func `sendVideo`(`url`: String, `thumbnailUrl`: String, `videoInfo`: VideoInfo) throws {
        try
    rustCallWithError(FfiConverterTypeRoomError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_send_video(self.pointer,
        FfiConverterString.lower(`url`),
        FfiConverterString.lower(`thumbnailUrl`),
        FfiConverterTypeVideoInfo.lower(`videoInfo`), $0
    )
}
    }

    public func `setName`(`name`: String?) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_set_name(self.pointer,
        FfiConverterOptionString.lower(`name`), $0
    )
}
    }

    public func `setTopic`(`topic`: String) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_set_topic(self.pointer,
        FfiConverterString.lower(`topic`), $0
    )
}
    }

    public func `topic`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_room_topic(self.pointer, $0
    )
}
        )
    }

    public func `uploadAvatar`(`mimeType`: String, `data`: [UInt8]) throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(self.pointer,
        FfiConverterString.lower(`mimeType`),
        FfiConverterSequenceUInt8.lower(`data`), $0
    )
}
    }
}



public struct FfiConverterTypeRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Room

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
        return Room(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Room) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> Room {
    return try FfiConverterTypeRoom.lift(pointer)
}

public func FfiConverterTypeRoom_lower(_ value: Room) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoom.lower(value)
}


public protocol RoomMemberProtocol {
    func `avatarUrl`()   -> String?
    func `canBan`()   -> Bool
    func `canInvite`()   -> Bool
    func `canKick`()   -> Bool
    func `canRedact`()   -> Bool
    func `canSendMessage`(`event`: MessageLikeEventType)   -> Bool
    func `canSendState`(`stateEvent`: StateEventType)   -> Bool
    func `canTriggerRoomNotification`()   -> Bool
    func `displayName`()   -> String?
    func `ignore`()  throws
    func `isAccountUser`()   -> Bool
    func `isIgnored`()   -> Bool
    func `isNameAmbiguous`()   -> Bool
    func `membership`()   -> MembershipState
    func `normalizedPowerLevel`()   -> Int64
    func `powerLevel`()   -> Int64
    func `unignore`()  throws
    func `userId`()   -> String

}

public class RoomMember: RoomMemberProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommember(pointer, $0) }
    }






    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func `canBan`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_ban(self.pointer, $0
    )
}
        )
    }

    public func `canInvite`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_invite(self.pointer, $0
    )
}
        )
    }

    public func `canKick`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_kick(self.pointer, $0
    )
}
        )
    }

    public func `canRedact`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_redact(self.pointer, $0
    )
}
        )
    }

    public func `canSendMessage`(`event`: MessageLikeEventType)  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_send_message(self.pointer,
        FfiConverterTypeMessageLikeEventType.lower(`event`), $0
    )
}
        )
    }

    public func `canSendState`(`stateEvent`: StateEventType)  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_send_state(self.pointer,
        FfiConverterTypeStateEventType.lower(`stateEvent`), $0
    )
}
        )
    }

    public func `canTriggerRoomNotification`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_can_trigger_room_notification(self.pointer, $0
    )
}
        )
    }

    public func `displayName`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_display_name(self.pointer, $0
    )
}
        )
    }

    public func `ignore`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_roommember_ignore(self.pointer, $0
    )
}
    }

    public func `isAccountUser`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_is_account_user(self.pointer, $0
    )
}
        )
    }

    public func `isIgnored`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_is_ignored(self.pointer, $0
    )
}
        )
    }

    public func `isNameAmbiguous`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_is_name_ambiguous(self.pointer, $0
    )
}
        )
    }

    public func `membership`()  -> MembershipState {
        return try!  FfiConverterTypeMembershipState.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_membership(self.pointer, $0
    )
}
        )
    }

    public func `normalizedPowerLevel`()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_normalized_power_level(self.pointer, $0
    )
}
        )
    }

    public func `powerLevel`()  -> Int64 {
        return try!  FfiConverterInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_power_level(self.pointer, $0
    )
}
        )
    }

    public func `unignore`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_roommember_unignore(self.pointer, $0
    )
}
    }

    public func `userId`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_roommember_user_id(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeRoomMember: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMember

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
        return RoomMember(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMember_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(pointer)
}

public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMember.lower(value)
}


public protocol RoomMessageEventContentProtocol {

}

public class RoomMessageEventContent: RoomMessageEventContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontent(pointer, $0) }
    }





}



public struct FfiConverterTypeRoomMessageEventContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RoomMessageEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RoomMessageEventContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContent {
        return RoomMessageEventContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RoomMessageEventContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRoomMessageEventContent_lift(_ pointer: UnsafeMutableRawPointer) throws -> RoomMessageEventContent {
    return try FfiConverterTypeRoomMessageEventContent.lift(pointer)
}

public func FfiConverterTypeRoomMessageEventContent_lower(_ value: RoomMessageEventContent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRoomMessageEventContent.lower(value)
}


public protocol SessionVerificationControllerProtocol {
    func `approveVerification`()  throws
    func `cancelVerification`()  throws
    func `declineVerification`()  throws
    func `isVerified`()   -> Bool
    func `requestVerification`()  throws
    func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)
    func `startSasVerification`()  throws

}

public class SessionVerificationController: SessionVerificationControllerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(pointer, $0) }
    }






    public func `approveVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(self.pointer, $0
    )
}
    }

    public func `cancelVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(self.pointer, $0
    )
}
    }

    public func `declineVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(self.pointer, $0
    )
}
    }

    public func `isVerified`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_is_verified(self.pointer, $0
    )
}
        )
    }

    public func `requestVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_verification(self.pointer, $0
    )
}
    }

    public func `setDelegate`(`delegate`: SessionVerificationControllerDelegate?)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(self.pointer,
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(`delegate`), $0
    )
}
    }

    public func `startSasVerification`() throws {
        try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(self.pointer, $0
    )
}
    }
}



public struct FfiConverterTypeSessionVerificationController: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationController

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationController_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationController {
    return try FfiConverterTypeSessionVerificationController.lift(pointer)
}

public func FfiConverterTypeSessionVerificationController_lower(_ value: SessionVerificationController) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationController.lower(value)
}


public protocol SessionVerificationEmojiProtocol {
    func `description`()   -> String
    func `symbol`()   -> String

}

public class SessionVerificationEmoji: SessionVerificationEmojiProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(pointer, $0) }
    }






    public func `description`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(self.pointer, $0
    )
}
        )
    }

    public func `symbol`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionVerificationEmoji

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSessionVerificationEmoji_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionVerificationEmoji {
    return try FfiConverterTypeSessionVerificationEmoji.lift(pointer)
}

public func FfiConverterTypeSessionVerificationEmoji_lower(_ value: SessionVerificationEmoji) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionVerificationEmoji.lower(value)
}


public protocol SlidingSyncProtocol {
    func `addCachedList`(`listBuilder`: SlidingSyncListBuilder)  throws -> SlidingSyncList?
    func `addCommonExtensions`()
    func `addList`(`listBuilder`: SlidingSyncListBuilder)   -> TaskHandle
    func `getRoom`(`roomId`: String)  throws -> SlidingSyncRoom?
    func `getRooms`(`roomIds`: [String])  throws -> [SlidingSyncRoom?]
    func `resetLists`()  throws
    func `setObserver`(`observer`: SlidingSyncObserver?)
    func `subscribeToRoom`(`roomId`: String, `settings`: RoomSubscription?)  throws -> TaskHandle
    func `sync`()   -> TaskHandle
    func `unsubscribeFromRoom`(`roomId`: String)  throws -> TaskHandle

}

public class SlidingSync: SlidingSyncProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_slidingsync(pointer, $0) }
    }






    public func `addCachedList`(`listBuilder`: SlidingSyncListBuilder) throws -> SlidingSyncList? {
        return try  FfiConverterOptionTypeSlidingSyncList.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_add_cached_list(self.pointer,
        FfiConverterTypeSlidingSyncListBuilder.lower(`listBuilder`), $0
    )
}
        )
    }

    public func `addCommonExtensions`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsync_add_common_extensions(self.pointer, $0
    )
}
    }

    public func `addList`(`listBuilder`: SlidingSyncListBuilder)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsync_add_list(self.pointer,
        FfiConverterTypeSlidingSyncListBuilder.lower(`listBuilder`), $0
    )
}
        )
    }

    public func `getRoom`(`roomId`: String) throws -> SlidingSyncRoom? {
        return try  FfiConverterOptionTypeSlidingSyncRoom.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_get_room(self.pointer,
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }

    public func `getRooms`(`roomIds`: [String]) throws -> [SlidingSyncRoom?] {
        return try  FfiConverterSequenceOptionTypeSlidingSyncRoom.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_get_rooms(self.pointer,
        FfiConverterSequenceString.lower(`roomIds`), $0
    )
}
        )
    }

    public func `resetLists`() throws {
        try
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_reset_lists(self.pointer, $0
    )
}
    }

    public func `setObserver`(`observer`: SlidingSyncObserver?)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsync_set_observer(self.pointer,
        FfiConverterOptionCallbackInterfaceSlidingSyncObserver.lower(`observer`), $0
    )
}
    }

    public func `subscribeToRoom`(`roomId`: String, `settings`: RoomSubscription?) throws -> TaskHandle {
        return try  FfiConverterTypeTaskHandle.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_subscribe_to_room(self.pointer,
        FfiConverterString.lower(`roomId`),
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
        )
    }

    public func `sync`()  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsync_sync(self.pointer, $0
    )
}
        )
    }

    public func `unsubscribeFromRoom`(`roomId`: String) throws -> TaskHandle {
        return try  FfiConverterTypeTaskHandle.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsync_unsubscribe_from_room(self.pointer,
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSync: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSync

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSync {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSync, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSync {
        return SlidingSync(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSync) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSync_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSync {
    return try FfiConverterTypeSlidingSync.lift(pointer)
}

public func FfiConverterTypeSlidingSync_lower(_ value: SlidingSync) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSync.lower(value)
}


public protocol SlidingSyncBuilderProtocol {
    func `addCachedList`(`listBuilder`: SlidingSyncListBuilder)  throws -> SlidingSyncBuilder
    func `addList`(`listBuilder`: SlidingSyncListBuilder)   -> SlidingSyncBuilder
    func `build`()  throws -> SlidingSync
    func `bumpEventTypes`(`bumpEventTypes`: [String])   -> SlidingSyncBuilder
    func `homeserver`(`url`: String)  throws -> SlidingSyncBuilder
    func `storageKey`(`name`: String?)   -> SlidingSyncBuilder
    func `withoutAccountDataExtension`()   -> SlidingSyncBuilder
    func `withoutE2eeExtension`()   -> SlidingSyncBuilder
    func `withoutReceiptExtension`()   -> SlidingSyncBuilder
    func `withoutToDeviceExtension`()   -> SlidingSyncBuilder
    func `withoutTypingExtension`()   -> SlidingSyncBuilder
    func `withAllExtensions`()   -> SlidingSyncBuilder
    func `withCommonExtensions`()   -> SlidingSyncBuilder

}

public class SlidingSyncBuilder: SlidingSyncBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_slidingsyncbuilder(pointer, $0) }
    }






    public func `addCachedList`(`listBuilder`: SlidingSyncListBuilder) throws -> SlidingSyncBuilder {
        return try  FfiConverterTypeSlidingSyncBuilder.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_add_cached_list(self.pointer,
        FfiConverterTypeSlidingSyncListBuilder.lower(`listBuilder`), $0
    )
}
        )
    }

    public func `addList`(`listBuilder`: SlidingSyncListBuilder)  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_add_list(self.pointer,
        FfiConverterTypeSlidingSyncListBuilder.lower(`listBuilder`), $0
    )
}
        )
    }

    public func `build`() throws -> SlidingSync {
        return try  FfiConverterTypeSlidingSync.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_build(self.pointer, $0
    )
}
        )
    }

    public func `bumpEventTypes`(`bumpEventTypes`: [String])  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_bump_event_types(self.pointer,
        FfiConverterSequenceString.lower(`bumpEventTypes`), $0
    )
}
        )
    }

    public func `homeserver`(`url`: String) throws -> SlidingSyncBuilder {
        return try  FfiConverterTypeSlidingSyncBuilder.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_homeserver(self.pointer,
        FfiConverterString.lower(`url`), $0
    )
}
        )
    }

    public func `storageKey`(`name`: String?)  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_storage_key(self.pointer,
        FfiConverterOptionString.lower(`name`), $0
    )
}
        )
    }

    public func `withoutAccountDataExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_without_account_data_extension(self.pointer, $0
    )
}
        )
    }

    public func `withoutE2eeExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_without_e2ee_extension(self.pointer, $0
    )
}
        )
    }

    public func `withoutReceiptExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_without_receipt_extension(self.pointer, $0
    )
}
        )
    }

    public func `withoutToDeviceExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_without_to_device_extension(self.pointer, $0
    )
}
        )
    }

    public func `withoutTypingExtension`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_without_typing_extension(self.pointer, $0
    )
}
        )
    }

    public func `withAllExtensions`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_with_all_extensions(self.pointer, $0
    )
}
        )
    }

    public func `withCommonExtensions`()  -> SlidingSyncBuilder {
        return try!  FfiConverterTypeSlidingSyncBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncbuilder_with_common_extensions(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncBuilder {
        return SlidingSyncBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncBuilder {
    return try FfiConverterTypeSlidingSyncBuilder.lift(pointer)
}

public func FfiConverterTypeSlidingSyncBuilder_lower(_ value: SlidingSyncBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncBuilder.lower(value)
}


public protocol SlidingSyncListProtocol {
    func `addRange`(`start`: UInt32, `end`: UInt32)  throws
    func `currentRoomCount`()   -> UInt32?
    func `currentRoomList`()   -> [RoomListEntry]
    func `getTimelineLimit`()   -> UInt32?
    func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)   -> TaskHandle
    func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)   -> TaskHandle
    func `observeState`(`observer`: SlidingSyncListStateObserver)   -> TaskHandle
    func `resetRanges`()  throws
    func `setRange`(`start`: UInt32, `end`: UInt32)  throws
    func `setTimelineLimit`(`value`: UInt32)
    func `unsetTimelineLimit`()

}

public class SlidingSyncList: SlidingSyncListProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_slidingsynclist(pointer, $0) }
    }






    public func `addRange`(`start`: UInt32, `end`: UInt32) throws {
        try
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_add_range(self.pointer,
        FfiConverterUInt32.lower(`start`),
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }

    public func `currentRoomCount`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_current_room_count(self.pointer, $0
    )
}
        )
    }

    public func `currentRoomList`()  -> [RoomListEntry] {
        return try!  FfiConverterSequenceTypeRoomListEntry.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_current_room_list(self.pointer, $0
    )
}
        )
    }

    public func `getTimelineLimit`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_get_timeline_limit(self.pointer, $0
    )
}
        )
    }

    public func `observeRoomsCount`(`observer`: SlidingSyncListRoomsCountObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_observe_rooms_count(self.pointer,
        FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `observeRoomList`(`observer`: SlidingSyncListRoomListObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_observe_room_list(self.pointer,
        FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `observeState`(`observer`: SlidingSyncListStateObserver)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_observe_state(self.pointer,
        FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lower(`observer`), $0
    )
}
        )
    }

    public func `resetRanges`() throws {
        try
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_reset_ranges(self.pointer, $0
    )
}
    }

    public func `setRange`(`start`: UInt32, `end`: UInt32) throws {
        try
    rustCallWithError(FfiConverterTypeSlidingSyncError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_set_range(self.pointer,
        FfiConverterUInt32.lower(`start`),
        FfiConverterUInt32.lower(`end`), $0
    )
}
    }

    public func `setTimelineLimit`(`value`: UInt32)  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_set_timeline_limit(self.pointer,
        FfiConverterUInt32.lower(`value`), $0
    )
}
    }

    public func `unsetTimelineLimit`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclist_unset_timeline_limit(self.pointer, $0
    )
}
    }
}



public struct FfiConverterTypeSlidingSyncList: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncList

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncList {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncList, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncList {
        return SlidingSyncList(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncList) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncList_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncList {
    return try FfiConverterTypeSlidingSyncList.lift(pointer)
}

public func FfiConverterTypeSlidingSyncList_lower(_ value: SlidingSyncList) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncList.lower(value)
}


public protocol SlidingSyncListBuilderProtocol {
    func `addRange`(`from`: UInt32, `toIncluded`: UInt32)   -> SlidingSyncListBuilder
    func `filters`(`filters`: SlidingSyncRequestListFilters)   -> SlidingSyncListBuilder
    func `noFilters`()   -> SlidingSyncListBuilder
    func `noTimelineLimit`()   -> SlidingSyncListBuilder
    func `onceBuilt`(`callback`: SlidingSyncListOnceBuilt)   -> SlidingSyncListBuilder
    func `requiredState`(`requiredState`: [RequiredState])   -> SlidingSyncListBuilder
    func `resetRanges`()   -> SlidingSyncListBuilder
    func `sort`(`sort`: [String])   -> SlidingSyncListBuilder
    func `syncModeGrowing`(`batchSize`: UInt32, `maximumNumberOfRoomsToFetch`: UInt32?)   -> SlidingSyncListBuilder
    func `syncModePaging`(`batchSize`: UInt32, `maximumNumberOfRoomsToFetch`: UInt32?)   -> SlidingSyncListBuilder
    func `syncModeSelective`()   -> SlidingSyncListBuilder
    func `timelineLimit`(`limit`: UInt32)   -> SlidingSyncListBuilder

}

public class SlidingSyncListBuilder: SlidingSyncListBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`name`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_slidingsynclistbuilder_new(
        FfiConverterString.lower(`name`), $0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_slidingsynclistbuilder(pointer, $0) }
    }






    public func `addRange`(`from`: UInt32, `toIncluded`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_add_range(self.pointer,
        FfiConverterUInt32.lower(`from`),
        FfiConverterUInt32.lower(`toIncluded`), $0
    )
}
        )
    }

    public func `filters`(`filters`: SlidingSyncRequestListFilters)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_filters(self.pointer,
        FfiConverterTypeSlidingSyncRequestListFilters.lower(`filters`), $0
    )
}
        )
    }

    public func `noFilters`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_no_filters(self.pointer, $0
    )
}
        )
    }

    public func `noTimelineLimit`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_no_timeline_limit(self.pointer, $0
    )
}
        )
    }

    public func `onceBuilt`(`callback`: SlidingSyncListOnceBuilt)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_once_built(self.pointer,
        FfiConverterCallbackInterfaceSlidingSyncListOnceBuilt.lower(`callback`), $0
    )
}
        )
    }

    public func `requiredState`(`requiredState`: [RequiredState])  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_required_state(self.pointer,
        FfiConverterSequenceTypeRequiredState.lower(`requiredState`), $0
    )
}
        )
    }

    public func `resetRanges`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_reset_ranges(self.pointer, $0
    )
}
        )
    }

    public func `sort`(`sort`: [String])  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_sort(self.pointer,
        FfiConverterSequenceString.lower(`sort`), $0
    )
}
        )
    }

    public func `syncModeGrowing`(`batchSize`: UInt32, `maximumNumberOfRoomsToFetch`: UInt32?)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_sync_mode_growing(self.pointer,
        FfiConverterUInt32.lower(`batchSize`),
        FfiConverterOptionUInt32.lower(`maximumNumberOfRoomsToFetch`), $0
    )
}
        )
    }

    public func `syncModePaging`(`batchSize`: UInt32, `maximumNumberOfRoomsToFetch`: UInt32?)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_sync_mode_paging(self.pointer,
        FfiConverterUInt32.lower(`batchSize`),
        FfiConverterOptionUInt32.lower(`maximumNumberOfRoomsToFetch`), $0
    )
}
        )
    }

    public func `syncModeSelective`()  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_sync_mode_selective(self.pointer, $0
    )
}
        )
    }

    public func `timelineLimit`(`limit`: UInt32)  -> SlidingSyncListBuilder {
        return try!  FfiConverterTypeSlidingSyncListBuilder.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsynclistbuilder_timeline_limit(self.pointer,
        FfiConverterUInt32.lower(`limit`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncListBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncListBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncListBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncListBuilder {
        return SlidingSyncListBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncListBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncListBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncListBuilder {
    return try FfiConverterTypeSlidingSyncListBuilder.lift(pointer)
}

public func FfiConverterTypeSlidingSyncListBuilder_lower(_ value: SlidingSyncListBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncListBuilder.lower(value)
}


public protocol SlidingSyncRoomProtocol {
    func `addTimelineListener`(`listener`: TimelineListener)  throws -> SlidingSyncAddTimelineListenerResult
    func `avatarUrl`()   -> String?
    func `fullRoom`()   -> Room?
    func `hasUnreadNotifications`()   -> Bool
    func `isDm`()   -> Bool?
    func `isInitial`()   -> Bool?
    func `latestRoomMessage`()   -> EventTimelineItem?
    func `name`()   -> String?
    func `roomId`()   -> String
    func `subscribeToRoom`(`settings`: RoomSubscription?)   -> TaskHandle
    func `unreadNotifications`()   -> UnreadNotificationsCount
    func `unsubscribeFromRoom`()   -> TaskHandle

}

public class SlidingSyncRoom: SlidingSyncRoomProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_slidingsyncroom(pointer, $0) }
    }






    public func `addTimelineListener`(`listener`: TimelineListener) throws -> SlidingSyncAddTimelineListenerResult {
        return try  FfiConverterTypeSlidingSyncAddTimelineListenerResult.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_add_timeline_listener(self.pointer,
        FfiConverterCallbackInterfaceTimelineListener.lower(`listener`), $0
    )
}
        )
    }

    public func `avatarUrl`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_avatar_url(self.pointer, $0
    )
}
        )
    }

    public func `fullRoom`()  -> Room? {
        return try!  FfiConverterOptionTypeRoom.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_full_room(self.pointer, $0
    )
}
        )
    }

    public func `hasUnreadNotifications`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_has_unread_notifications(self.pointer, $0
    )
}
        )
    }

    public func `isDm`()  -> Bool? {
        return try!  FfiConverterOptionBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_is_dm(self.pointer, $0
    )
}
        )
    }

    public func `isInitial`()  -> Bool? {
        return try!  FfiConverterOptionBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_is_initial(self.pointer, $0
    )
}
        )
    }

    public func `latestRoomMessage`()  -> EventTimelineItem? {
        return try!  FfiConverterOptionTypeEventTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_latest_room_message(self.pointer, $0
    )
}
        )
    }

    public func `name`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_name(self.pointer, $0
    )
}
        )
    }

    public func `roomId`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_room_id(self.pointer, $0
    )
}
        )
    }

    public func `subscribeToRoom`(`settings`: RoomSubscription?)  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_subscribe_to_room(self.pointer,
        FfiConverterOptionTypeRoomSubscription.lower(`settings`), $0
    )
}
        )
    }

    public func `unreadNotifications`()  -> UnreadNotificationsCount {
        return try!  FfiConverterTypeUnreadNotificationsCount.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_unread_notifications(self.pointer, $0
    )
}
        )
    }

    public func `unsubscribeFromRoom`()  -> TaskHandle {
        return try!  FfiConverterTypeTaskHandle.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_slidingsyncroom_unsubscribe_from_room(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSlidingSyncRoom: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SlidingSyncRoom

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRoom {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SlidingSyncRoom, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncRoom {
        return SlidingSyncRoom(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SlidingSyncRoom) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSlidingSyncRoom_lift(_ pointer: UnsafeMutableRawPointer) throws -> SlidingSyncRoom {
    return try FfiConverterTypeSlidingSyncRoom.lift(pointer)
}

public func FfiConverterTypeSlidingSyncRoom_lower(_ value: SlidingSyncRoom) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSlidingSyncRoom.lower(value)
}


public protocol SpanProtocol {
    func `enter`()
    func `exit`()
    func `isNone`()   -> Bool

}

public class Span: SpanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`file`: String, `line`: UInt32, `column`: UInt32, `level`: LogLevel, `target`: String, `name`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(`file`),
        FfiConverterUInt32.lower(`line`),
        FfiConverterUInt32.lower(`column`),
        FfiConverterTypeLogLevel.lower(`level`),
        FfiConverterString.lower(`target`),
        FfiConverterString.lower(`name`), $0)
})
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_span(pointer, $0) }
    }



    public static func `current`()  -> Span {
        return Span(unsafeFromRawPointer: try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_current($0)
})
    }






    public func `enter`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_span_enter(self.pointer, $0
    )
}
    }

    public func `exit`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_span_exit(self.pointer, $0
    )
}
    }

    public func `isNone`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_span_is_none(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSpan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Span

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Span {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Span, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
        return Span(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Span) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSpan_lift(_ pointer: UnsafeMutableRawPointer) throws -> Span {
    return try FfiConverterTypeSpan.lift(pointer)
}

public func FfiConverterTypeSpan_lower(_ value: Span) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpan.lower(value)
}


public protocol TaskHandleProtocol {
    func `cancel`()
    func `isFinished`()   -> Bool

}

public class TaskHandle: TaskHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_taskhandle(pointer, $0) }
    }






    public func `cancel`()  {
        try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(self.pointer, $0
    )
}
    }

    public func `isFinished`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTaskHandle: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TaskHandle

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
        return TaskHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTaskHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> TaskHandle {
    return try FfiConverterTypeTaskHandle.lift(pointer)
}

public func FfiConverterTypeTaskHandle_lower(_ value: TaskHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTaskHandle.lower(value)
}


public protocol TimelineDiffProtocol {
    func `append`()   -> [TimelineItem]?
    func `change`()   -> TimelineChange
    func `insert`()   -> InsertData?
    func `pushBack`()   -> TimelineItem?
    func `pushFront`()   -> TimelineItem?
    func `remove`()   -> UInt32?
    func `reset`()   -> [TimelineItem]?
    func `set`()   -> SetData?

}

public class TimelineDiff: TimelineDiffProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelinediff(pointer, $0) }
    }






    public func `append`()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(self.pointer, $0
    )
}
        )
    }

    public func `change`()  -> TimelineChange {
        return try!  FfiConverterTypeTimelineChange.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(self.pointer, $0
    )
}
        )
    }

    public func `insert`()  -> InsertData? {
        return try!  FfiConverterOptionTypeInsertData.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(self.pointer, $0
    )
}
        )
    }

    public func `pushBack`()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(self.pointer, $0
    )
}
        )
    }

    public func `pushFront`()  -> TimelineItem? {
        return try!  FfiConverterOptionTypeTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(self.pointer, $0
    )
}
        )
    }

    public func `remove`()  -> UInt32? {
        return try!  FfiConverterOptionUInt32.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(self.pointer, $0
    )
}
        )
    }

    public func `reset`()  -> [TimelineItem]? {
        return try!  FfiConverterOptionSequenceTypeTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(self.pointer, $0
    )
}
        )
    }

    public func `set`()  -> SetData? {
        return try!  FfiConverterOptionTypeSetData.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineDiff: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
        return TimelineDiff(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineDiff_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineDiff {
    return try FfiConverterTypeTimelineDiff.lift(pointer)
}

public func FfiConverterTypeTimelineDiff_lower(_ value: TimelineDiff) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineDiff.lower(value)
}


public protocol TimelineEventProtocol {
    func `eventId`()   -> String
    func `eventType`()  throws -> TimelineEventType
    func `senderId`()   -> String
    func `timestamp`()   -> UInt64

}

public class TimelineEvent: TimelineEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineevent(pointer, $0) }
    }






    public func `eventId`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(self.pointer, $0
    )
}
        )
    }

    public func `eventType`() throws -> TimelineEventType {
        return try  FfiConverterTypeTimelineEventType.lift(
            try
    rustCallWithError(FfiConverterTypeClientError.self) {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(self.pointer, $0
    )
}
        )
    }

    public func `senderId`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(self.pointer, $0
    )
}
        )
    }

    public func `timestamp`()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineEvent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
        return TimelineEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineEvent {
    return try FfiConverterTypeTimelineEvent.lift(pointer)
}

public func FfiConverterTypeTimelineEvent_lower(_ value: TimelineEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineEvent.lower(value)
}


public protocol TimelineItemProtocol {
    func `asEvent`()   -> EventTimelineItem?
    func `asVirtual`()   -> VirtualTimelineItem?
    func `fmtDebug`()   -> String

}

public class TimelineItem: TimelineItemProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitem(pointer, $0) }
    }






    public func `asEvent`()  -> EventTimelineItem? {
        return try!  FfiConverterOptionTypeEventTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(self.pointer, $0
    )
}
        )
    }

    public func `asVirtual`()  -> VirtualTimelineItem? {
        return try!  FfiConverterOptionTypeVirtualTimelineItem.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(self.pointer, $0
    )
}
        )
    }

    public func `fmtDebug`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineItem: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
        return TimelineItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItem {
    return try FfiConverterTypeTimelineItem.lift(pointer)
}

public func FfiConverterTypeTimelineItem_lower(_ value: TimelineItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItem.lower(value)
}


public protocol TimelineItemContentProtocol {
    func `asMessage`()   -> Message?
    func `kind`()   -> TimelineItemContentKind

}

public class TimelineItemContent: TimelineItemContentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitemcontent(pointer, $0) }
    }






    public func `asMessage`()  -> Message? {
        return try!  FfiConverterOptionTypeMessage.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_as_message(self.pointer, $0
    )
}
        )
    }

    public func `kind`()  -> TimelineItemContentKind {
        return try!  FfiConverterTypeTimelineItemContentKind.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_timelineitemcontent_kind(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeTimelineItemContent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
        return TimelineItemContent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimelineItemContent_lift(_ pointer: UnsafeMutableRawPointer) throws -> TimelineItemContent {
    return try FfiConverterTypeTimelineItemContent.lift(pointer)
}

public func FfiConverterTypeTimelineItemContent_lower(_ value: TimelineItemContent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimelineItemContent.lower(value)
}


public protocol UnreadNotificationsCountProtocol {
    func `hasNotifications`()   -> Bool
    func `highlightCount`()   -> UInt32
    func `notificationCount`()   -> UInt32

}

public class UnreadNotificationsCount: UnreadNotificationsCountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(pointer, $0) }
    }






    public func `hasNotifications`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(self.pointer, $0
    )
}
        )
    }

    public func `highlightCount`()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(self.pointer, $0
    )
}
        )
    }

    public func `notificationCount`()  -> UInt32 {
        return try!  FfiConverterUInt32.lift(
            try!
    rustCall() {

    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnreadNotificationsCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeUnreadNotificationsCount_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnreadNotificationsCount {
    return try FfiConverterTypeUnreadNotificationsCount.lift(pointer)
}

public func FfiConverterTypeUnreadNotificationsCount_lower(_ value: UnreadNotificationsCount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnreadNotificationsCount.lower(value)
}


public struct AudioInfo {
    public var `duration`: UInt64?
    public var `size`: UInt64?
    public var `mimetype`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `size`: UInt64?, `mimetype`: String?) {
        self.`duration` = `duration`
        self.`size` = `size`
        self.`mimetype` = `mimetype`
    }
}


extension AudioInfo: Equatable, Hashable {
    public static func ==(lhs: AudioInfo, rhs: AudioInfo) -> Bool {
        if lhs.`duration` != rhs.`duration` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`mimetype` != rhs.`mimetype` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`duration`)
        hasher.combine(`size`)
        hasher.combine(`mimetype`)
    }
}


public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return try AudioInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf),
            `size`: FfiConverterOptionUInt64.read(from: &buf),
            `mimetype`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
    }
}


public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: AudioInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: AudioInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return try AudioMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `source`: FfiConverterTypeMediaSource.read(from: &buf),
            `info`: FfiConverterOptionTypeAudioInfo.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct CreateRoomParameters {
    public var `name`: String?
    public var `topic`: String?
    public var `isEncrypted`: Bool
    public var `isDirect`: Bool
    public var `visibility`: RoomVisibility
    public var `preset`: RoomPreset
    public var `invite`: [String]?
    public var `avatar`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String?, `topic`: String? = nil, `isEncrypted`: Bool, `isDirect`: Bool = false, `visibility`: RoomVisibility, `preset`: RoomPreset, `invite`: [String]? = nil, `avatar`: String? = nil) {
        self.`name` = `name`
        self.`topic` = `topic`
        self.`isEncrypted` = `isEncrypted`
        self.`isDirect` = `isDirect`
        self.`visibility` = `visibility`
        self.`preset` = `preset`
        self.`invite` = `invite`
        self.`avatar` = `avatar`
    }
}


extension CreateRoomParameters: Equatable, Hashable {
    public static func ==(lhs: CreateRoomParameters, rhs: CreateRoomParameters) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`topic` != rhs.`topic` {
            return false
        }
        if lhs.`isEncrypted` != rhs.`isEncrypted` {
            return false
        }
        if lhs.`isDirect` != rhs.`isDirect` {
            return false
        }
        if lhs.`visibility` != rhs.`visibility` {
            return false
        }
        if lhs.`preset` != rhs.`preset` {
            return false
        }
        if lhs.`invite` != rhs.`invite` {
            return false
        }
        if lhs.`avatar` != rhs.`avatar` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`topic`)
        hasher.combine(`isEncrypted`)
        hasher.combine(`isDirect`)
        hasher.combine(`visibility`)
        hasher.combine(`preset`)
        hasher.combine(`invite`)
        hasher.combine(`avatar`)
    }
}


public struct FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateRoomParameters {
        return try CreateRoomParameters(
            `name`: FfiConverterOptionString.read(from: &buf),
            `topic`: FfiConverterOptionString.read(from: &buf),
            `isEncrypted`: FfiConverterBool.read(from: &buf),
            `isDirect`: FfiConverterBool.read(from: &buf),
            `visibility`: FfiConverterTypeRoomVisibility.read(from: &buf),
            `preset`: FfiConverterTypeRoomPreset.read(from: &buf),
            `invite`: FfiConverterOptionSequenceString.read(from: &buf),
            `avatar`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateRoomParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`topic`, into: &buf)
        FfiConverterBool.write(value.`isEncrypted`, into: &buf)
        FfiConverterBool.write(value.`isDirect`, into: &buf)
        FfiConverterTypeRoomVisibility.write(value.`visibility`, into: &buf)
        FfiConverterTypeRoomPreset.write(value.`preset`, into: &buf)
        FfiConverterOptionSequenceString.write(value.`invite`, into: &buf)
        FfiConverterOptionString.write(value.`avatar`, into: &buf)
    }
}


public func FfiConverterTypeCreateRoomParameters_lift(_ buf: RustBuffer) throws -> CreateRoomParameters {
    return try FfiConverterTypeCreateRoomParameters.lift(buf)
}

public func FfiConverterTypeCreateRoomParameters_lower(_ value: CreateRoomParameters) -> RustBuffer {
    return FfiConverterTypeCreateRoomParameters.lower(value)
}


public struct EmoteMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension EmoteMessageContent: Equatable, Hashable {
    public static func ==(lhs: EmoteMessageContent, rhs: EmoteMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return try EmoteMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct EventTimelineItemDebugInfo {
    public var `model`: String
    public var `originalJson`: String?
    public var `latestEditJson`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`model`: String, `originalJson`: String?, `latestEditJson`: String?) {
        self.`model` = `model`
        self.`originalJson` = `originalJson`
        self.`latestEditJson` = `latestEditJson`
    }
}


extension EventTimelineItemDebugInfo: Equatable, Hashable {
    public static func ==(lhs: EventTimelineItemDebugInfo, rhs: EventTimelineItemDebugInfo) -> Bool {
        if lhs.`model` != rhs.`model` {
            return false
        }
        if lhs.`originalJson` != rhs.`originalJson` {
            return false
        }
        if lhs.`latestEditJson` != rhs.`latestEditJson` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`model`)
        hasher.combine(`originalJson`)
        hasher.combine(`latestEditJson`)
    }
}


public struct FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItemDebugInfo {
        return try EventTimelineItemDebugInfo(
            `model`: FfiConverterString.read(from: &buf),
            `originalJson`: FfiConverterOptionString.read(from: &buf),
            `latestEditJson`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItemDebugInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`model`, into: &buf)
        FfiConverterOptionString.write(value.`originalJson`, into: &buf)
        FfiConverterOptionString.write(value.`latestEditJson`, into: &buf)
    }
}


public func FfiConverterTypeEventTimelineItemDebugInfo_lift(_ buf: RustBuffer) throws -> EventTimelineItemDebugInfo {
    return try FfiConverterTypeEventTimelineItemDebugInfo.lift(buf)
}

public func FfiConverterTypeEventTimelineItemDebugInfo_lower(_ value: EventTimelineItemDebugInfo) -> RustBuffer {
    return FfiConverterTypeEventTimelineItemDebugInfo.lower(value)
}


public struct FileInfo {
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?) {
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
    }
}



public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return try FileInfo(
            `mimetype`: FfiConverterOptionString.read(from: &buf),
            `size`: FfiConverterOptionUInt64.read(from: &buf),
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf),
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
    }
}


public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: FileInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return try FileMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `source`: FfiConverterTypeMediaSource.read(from: &buf),
            `info`: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody {
    public var `format`: MessageFormat
    public var `body`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`format`: MessageFormat, `body`: String) {
        self.`format` = `format`
        self.`body` = `body`
    }
}


extension FormattedBody: Equatable, Hashable {
    public static func ==(lhs: FormattedBody, rhs: FormattedBody) -> Bool {
        if lhs.`format` != rhs.`format` {
            return false
        }
        if lhs.`body` != rhs.`body` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`format`)
        hasher.combine(`body`)
    }
}


public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return try FormattedBody(
            `format`: FfiConverterTypeMessageFormat.read(from: &buf),
            `body`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.`format`, into: &buf)
        FfiConverterString.write(value.`body`, into: &buf)
    }
}


public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct HttpPusherData {
    public var `url`: String
    public var `format`: PushFormat?
    public var `defaultPayload`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`url`: String, `format`: PushFormat?, `defaultPayload`: String?) {
        self.`url` = `url`
        self.`format` = `format`
        self.`defaultPayload` = `defaultPayload`
    }
}


extension HttpPusherData: Equatable, Hashable {
    public static func ==(lhs: HttpPusherData, rhs: HttpPusherData) -> Bool {
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`format` != rhs.`format` {
            return false
        }
        if lhs.`defaultPayload` != rhs.`defaultPayload` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`url`)
        hasher.combine(`format`)
        hasher.combine(`defaultPayload`)
    }
}


public struct FfiConverterTypeHttpPusherData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpPusherData {
        return try HttpPusherData(
            `url`: FfiConverterString.read(from: &buf),
            `format`: FfiConverterOptionTypePushFormat.read(from: &buf),
            `defaultPayload`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpPusherData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`url`, into: &buf)
        FfiConverterOptionTypePushFormat.write(value.`format`, into: &buf)
        FfiConverterOptionString.write(value.`defaultPayload`, into: &buf)
    }
}


public func FfiConverterTypeHttpPusherData_lift(_ buf: RustBuffer) throws -> HttpPusherData {
    return try FfiConverterTypeHttpPusherData.lift(buf)
}

public func FfiConverterTypeHttpPusherData_lower(_ value: HttpPusherData) -> RustBuffer {
    return FfiConverterTypeHttpPusherData.lower(value)
}


public struct ImageInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return try ImageInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf),
            `width`: FfiConverterOptionUInt64.read(from: &buf),
            `mimetype`: FfiConverterOptionString.read(from: &buf),
            `size`: FfiConverterOptionUInt64.read(from: &buf),
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf),
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf),
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: ImageInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return try ImageMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `source`: FfiConverterTypeMediaSource.read(from: &buf),
            `info`: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


public struct InReplyToDetails {
    public var `eventId`: String
    public var `event`: RepliedToEventDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`eventId`: String, `event`: RepliedToEventDetails) {
        self.`eventId` = `eventId`
        self.`event` = `event`
    }
}



public struct FfiConverterTypeInReplyToDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InReplyToDetails {
        return try InReplyToDetails(
            `eventId`: FfiConverterString.read(from: &buf),
            `event`: FfiConverterTypeRepliedToEventDetails.read(from: &buf)
        )
    }

    public static func write(_ value: InReplyToDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`eventId`, into: &buf)
        FfiConverterTypeRepliedToEventDetails.write(value.`event`, into: &buf)
    }
}


public func FfiConverterTypeInReplyToDetails_lift(_ buf: RustBuffer) throws -> InReplyToDetails {
    return try FfiConverterTypeInReplyToDetails.lift(buf)
}

public func FfiConverterTypeInReplyToDetails_lower(_ value: InReplyToDetails) -> RustBuffer {
    return FfiConverterTypeInReplyToDetails.lower(value)
}


public struct InsertData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeInsertData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertData {
        return try InsertData(
            `index`: FfiConverterUInt32.read(from: &buf),
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: InsertData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeInsertData_lift(_ buf: RustBuffer) throws -> InsertData {
    return try FfiConverterTypeInsertData.lift(buf)
}

public func FfiConverterTypeInsertData_lower(_ value: InsertData) -> RustBuffer {
    return FfiConverterTypeInsertData.lower(value)
}


public struct MoveData {
    public var `oldIndex`: UInt32
    public var `newIndex`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`oldIndex`: UInt32, `newIndex`: UInt32) {
        self.`oldIndex` = `oldIndex`
        self.`newIndex` = `newIndex`
    }
}


extension MoveData: Equatable, Hashable {
    public static func ==(lhs: MoveData, rhs: MoveData) -> Bool {
        if lhs.`oldIndex` != rhs.`oldIndex` {
            return false
        }
        if lhs.`newIndex` != rhs.`newIndex` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`oldIndex`)
        hasher.combine(`newIndex`)
    }
}


public struct FfiConverterTypeMoveData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MoveData {
        return try MoveData(
            `oldIndex`: FfiConverterUInt32.read(from: &buf),
            `newIndex`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: MoveData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`oldIndex`, into: &buf)
        FfiConverterUInt32.write(value.`newIndex`, into: &buf)
    }
}


public func FfiConverterTypeMoveData_lift(_ buf: RustBuffer) throws -> MoveData {
    return try FfiConverterTypeMoveData.lift(buf)
}

public func FfiConverterTypeMoveData_lower(_ value: MoveData) -> RustBuffer {
    return FfiConverterTypeMoveData.lower(value)
}


public struct NoticeMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension NoticeMessageContent: Equatable, Hashable {
    public static func ==(lhs: NoticeMessageContent, rhs: NoticeMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return try NoticeMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct NotificationItem {
    public var `event`: TimelineEvent
    public var `roomId`: String
    public var `senderDisplayName`: String?
    public var `senderAvatarUrl`: String?
    public var `roomDisplayName`: String
    public var `roomAvatarUrl`: String?
    public var `roomCanonicalAlias`: String?
    public var `isNoisy`: Bool
    public var `isDirect`: Bool
    public var `isEncrypted`: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`event`: TimelineEvent, `roomId`: String, `senderDisplayName`: String?, `senderAvatarUrl`: String?, `roomDisplayName`: String, `roomAvatarUrl`: String?, `roomCanonicalAlias`: String?, `isNoisy`: Bool, `isDirect`: Bool, `isEncrypted`: Bool?) {
        self.`event` = `event`
        self.`roomId` = `roomId`
        self.`senderDisplayName` = `senderDisplayName`
        self.`senderAvatarUrl` = `senderAvatarUrl`
        self.`roomDisplayName` = `roomDisplayName`
        self.`roomAvatarUrl` = `roomAvatarUrl`
        self.`roomCanonicalAlias` = `roomCanonicalAlias`
        self.`isNoisy` = `isNoisy`
        self.`isDirect` = `isDirect`
        self.`isEncrypted` = `isEncrypted`
    }
}



public struct FfiConverterTypeNotificationItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItem {
        return try NotificationItem(
            `event`: FfiConverterTypeTimelineEvent.read(from: &buf),
            `roomId`: FfiConverterString.read(from: &buf),
            `senderDisplayName`: FfiConverterOptionString.read(from: &buf),
            `senderAvatarUrl`: FfiConverterOptionString.read(from: &buf),
            `roomDisplayName`: FfiConverterString.read(from: &buf),
            `roomAvatarUrl`: FfiConverterOptionString.read(from: &buf),
            `roomCanonicalAlias`: FfiConverterOptionString.read(from: &buf),
            `isNoisy`: FfiConverterBool.read(from: &buf),
            `isDirect`: FfiConverterBool.read(from: &buf),
            `isEncrypted`: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItem, into buf: inout [UInt8]) {
        FfiConverterTypeTimelineEvent.write(value.`event`, into: &buf)
        FfiConverterString.write(value.`roomId`, into: &buf)
        FfiConverterOptionString.write(value.`senderDisplayName`, into: &buf)
        FfiConverterOptionString.write(value.`senderAvatarUrl`, into: &buf)
        FfiConverterString.write(value.`roomDisplayName`, into: &buf)
        FfiConverterOptionString.write(value.`roomAvatarUrl`, into: &buf)
        FfiConverterOptionString.write(value.`roomCanonicalAlias`, into: &buf)
        FfiConverterBool.write(value.`isNoisy`, into: &buf)
        FfiConverterBool.write(value.`isDirect`, into: &buf)
        FfiConverterOptionBool.write(value.`isEncrypted`, into: &buf)
    }
}


public func FfiConverterTypeNotificationItem_lift(_ buf: RustBuffer) throws -> NotificationItem {
    return try FfiConverterTypeNotificationItem.lift(buf)
}

public func FfiConverterTypeNotificationItem_lower(_ value: NotificationItem) -> RustBuffer {
    return FfiConverterTypeNotificationItem.lower(value)
}


public struct PusherIdentifiers {
    public var `pushkey`: String
    public var `appId`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pushkey`: String, `appId`: String) {
        self.`pushkey` = `pushkey`
        self.`appId` = `appId`
    }
}


extension PusherIdentifiers: Equatable, Hashable {
    public static func ==(lhs: PusherIdentifiers, rhs: PusherIdentifiers) -> Bool {
        if lhs.`pushkey` != rhs.`pushkey` {
            return false
        }
        if lhs.`appId` != rhs.`appId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pushkey`)
        hasher.combine(`appId`)
    }
}


public struct FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherIdentifiers {
        return try PusherIdentifiers(
            `pushkey`: FfiConverterString.read(from: &buf),
            `appId`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PusherIdentifiers, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`pushkey`, into: &buf)
        FfiConverterString.write(value.`appId`, into: &buf)
    }
}


public func FfiConverterTypePusherIdentifiers_lift(_ buf: RustBuffer) throws -> PusherIdentifiers {
    return try FfiConverterTypePusherIdentifiers.lift(buf)
}

public func FfiConverterTypePusherIdentifiers_lower(_ value: PusherIdentifiers) -> RustBuffer {
    return FfiConverterTypePusherIdentifiers.lower(value)
}


public struct Reaction {
    public var `key`: String
    public var `count`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `count`: UInt64) {
        self.`key` = `key`
        self.`count` = `count`
    }
}


extension Reaction: Equatable, Hashable {
    public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`count` != rhs.`count` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`count`)
    }
}


public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return try Reaction(
            `key`: FfiConverterString.read(from: &buf),
            `count`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterUInt64.write(value.`count`, into: &buf)
    }
}


public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct Receipt {
    public var `timestamp`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`timestamp`: UInt64?) {
        self.`timestamp` = `timestamp`
    }
}


extension Receipt: Equatable, Hashable {
    public static func ==(lhs: Receipt, rhs: Receipt) -> Bool {
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`timestamp`)
    }
}


public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return try Receipt(
            `timestamp`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`timestamp`, into: &buf)
    }
}


public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


public struct RequiredState {
    public var `key`: String
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: String) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension RequiredState: Equatable, Hashable {
    public static func ==(lhs: RequiredState, rhs: RequiredState) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeRequiredState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequiredState {
        return try RequiredState(
            `key`: FfiConverterString.read(from: &buf),
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RequiredState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeRequiredState_lift(_ buf: RustBuffer) throws -> RequiredState {
    return try FfiConverterTypeRequiredState.lift(buf)
}

public func FfiConverterTypeRequiredState_lower(_ value: RequiredState) -> RustBuffer {
    return FfiConverterTypeRequiredState.lower(value)
}


public struct RoomSubscription {
    public var `requiredState`: [RequiredState]?
    public var `timelineLimit`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`requiredState`: [RequiredState]?, `timelineLimit`: UInt32?) {
        self.`requiredState` = `requiredState`
        self.`timelineLimit` = `timelineLimit`
    }
}


extension RoomSubscription: Equatable, Hashable {
    public static func ==(lhs: RoomSubscription, rhs: RoomSubscription) -> Bool {
        if lhs.`requiredState` != rhs.`requiredState` {
            return false
        }
        if lhs.`timelineLimit` != rhs.`timelineLimit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`requiredState`)
        hasher.combine(`timelineLimit`)
    }
}


public struct FfiConverterTypeRoomSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSubscription {
        return try RoomSubscription(
            `requiredState`: FfiConverterOptionSequenceTypeRequiredState.read(from: &buf),
            `timelineLimit`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSubscription, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRequiredState.write(value.`requiredState`, into: &buf)
        FfiConverterOptionUInt32.write(value.`timelineLimit`, into: &buf)
    }
}


public func FfiConverterTypeRoomSubscription_lift(_ buf: RustBuffer) throws -> RoomSubscription {
    return try FfiConverterTypeRoomSubscription.lift(buf)
}

public func FfiConverterTypeRoomSubscription_lower(_ value: RoomSubscription) -> RustBuffer {
    return FfiConverterTypeRoomSubscription.lower(value)
}


public struct SearchUsersResults {
    public var `results`: [UserProfile]
    public var `limited`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`results`: [UserProfile], `limited`: Bool) {
        self.`results` = `results`
        self.`limited` = `limited`
    }
}


extension SearchUsersResults: Equatable, Hashable {
    public static func ==(lhs: SearchUsersResults, rhs: SearchUsersResults) -> Bool {
        if lhs.`results` != rhs.`results` {
            return false
        }
        if lhs.`limited` != rhs.`limited` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`results`)
        hasher.combine(`limited`)
    }
}


public struct FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchUsersResults {
        return try SearchUsersResults(
            `results`: FfiConverterSequenceTypeUserProfile.read(from: &buf),
            `limited`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchUsersResults, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUserProfile.write(value.`results`, into: &buf)
        FfiConverterBool.write(value.`limited`, into: &buf)
    }
}


public func FfiConverterTypeSearchUsersResults_lift(_ buf: RustBuffer) throws -> SearchUsersResults {
    return try FfiConverterTypeSearchUsersResults.lift(buf)
}

public func FfiConverterTypeSearchUsersResults_lower(_ value: SearchUsersResults) -> RustBuffer {
    return FfiConverterTypeSearchUsersResults.lower(value)
}


public struct Session {
    public var `accessToken`: String
    public var `refreshToken`: String?
    public var `userId`: String
    public var `deviceId`: String
    public var `homeserverUrl`: String
    public var `slidingSyncProxy`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`accessToken`: String, `refreshToken`: String?, `userId`: String, `deviceId`: String, `homeserverUrl`: String, `slidingSyncProxy`: String?) {
        self.`accessToken` = `accessToken`
        self.`refreshToken` = `refreshToken`
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`homeserverUrl` = `homeserverUrl`
        self.`slidingSyncProxy` = `slidingSyncProxy`
    }
}


extension Session: Equatable, Hashable {
    public static func ==(lhs: Session, rhs: Session) -> Bool {
        if lhs.`accessToken` != rhs.`accessToken` {
            return false
        }
        if lhs.`refreshToken` != rhs.`refreshToken` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`homeserverUrl` != rhs.`homeserverUrl` {
            return false
        }
        if lhs.`slidingSyncProxy` != rhs.`slidingSyncProxy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`accessToken`)
        hasher.combine(`refreshToken`)
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`homeserverUrl`)
        hasher.combine(`slidingSyncProxy`)
    }
}


public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return try Session(
            `accessToken`: FfiConverterString.read(from: &buf),
            `refreshToken`: FfiConverterOptionString.read(from: &buf),
            `userId`: FfiConverterString.read(from: &buf),
            `deviceId`: FfiConverterString.read(from: &buf),
            `homeserverUrl`: FfiConverterString.read(from: &buf),
            `slidingSyncProxy`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`accessToken`, into: &buf)
        FfiConverterOptionString.write(value.`refreshToken`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterString.write(value.`homeserverUrl`, into: &buf)
        FfiConverterOptionString.write(value.`slidingSyncProxy`, into: &buf)
    }
}


public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


public struct SetData {
    public var `index`: UInt32
    public var `item`: TimelineItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `item`: TimelineItem) {
        self.`index` = `index`
        self.`item` = `item`
    }
}



public struct FfiConverterTypeSetData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetData {
        return try SetData(
            `index`: FfiConverterUInt32.read(from: &buf),
            `item`: FfiConverterTypeTimelineItem.read(from: &buf)
        )
    }

    public static func write(_ value: SetData, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterTypeTimelineItem.write(value.`item`, into: &buf)
    }
}


public func FfiConverterTypeSetData_lift(_ buf: RustBuffer) throws -> SetData {
    return try FfiConverterTypeSetData.lift(buf)
}

public func FfiConverterTypeSetData_lower(_ value: SetData) -> RustBuffer {
    return FfiConverterTypeSetData.lower(value)
}


public struct SlidingSyncAddTimelineListenerResult {
    public var `items`: [TimelineItem]
    public var `taskHandle`: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`items`: [TimelineItem], `taskHandle`: TaskHandle) {
        self.`items` = `items`
        self.`taskHandle` = `taskHandle`
    }
}



public struct FfiConverterTypeSlidingSyncAddTimelineListenerResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncAddTimelineListenerResult {
        return try SlidingSyncAddTimelineListenerResult(
            `items`: FfiConverterSequenceTypeTimelineItem.read(from: &buf),
            `taskHandle`: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncAddTimelineListenerResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTimelineItem.write(value.`items`, into: &buf)
        FfiConverterTypeTaskHandle.write(value.`taskHandle`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncAddTimelineListenerResult_lift(_ buf: RustBuffer) throws -> SlidingSyncAddTimelineListenerResult {
    return try FfiConverterTypeSlidingSyncAddTimelineListenerResult.lift(buf)
}

public func FfiConverterTypeSlidingSyncAddTimelineListenerResult_lower(_ value: SlidingSyncAddTimelineListenerResult) -> RustBuffer {
    return FfiConverterTypeSlidingSyncAddTimelineListenerResult.lower(value)
}


public struct SlidingSyncRequestListFilters {
    public var `isDm`: Bool?
    public var `spaces`: [String]
    public var `isEncrypted`: Bool?
    public var `isInvite`: Bool?
    public var `isTombstoned`: Bool?
    public var `roomTypes`: [String]
    public var `notRoomTypes`: [String]
    public var `roomNameLike`: String?
    public var `tags`: [String]
    public var `notTags`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`isDm`: Bool?, `spaces`: [String], `isEncrypted`: Bool?, `isInvite`: Bool?, `isTombstoned`: Bool?, `roomTypes`: [String], `notRoomTypes`: [String], `roomNameLike`: String?, `tags`: [String], `notTags`: [String]) {
        self.`isDm` = `isDm`
        self.`spaces` = `spaces`
        self.`isEncrypted` = `isEncrypted`
        self.`isInvite` = `isInvite`
        self.`isTombstoned` = `isTombstoned`
        self.`roomTypes` = `roomTypes`
        self.`notRoomTypes` = `notRoomTypes`
        self.`roomNameLike` = `roomNameLike`
        self.`tags` = `tags`
        self.`notTags` = `notTags`
    }
}


extension SlidingSyncRequestListFilters: Equatable, Hashable {
    public static func ==(lhs: SlidingSyncRequestListFilters, rhs: SlidingSyncRequestListFilters) -> Bool {
        if lhs.`isDm` != rhs.`isDm` {
            return false
        }
        if lhs.`spaces` != rhs.`spaces` {
            return false
        }
        if lhs.`isEncrypted` != rhs.`isEncrypted` {
            return false
        }
        if lhs.`isInvite` != rhs.`isInvite` {
            return false
        }
        if lhs.`isTombstoned` != rhs.`isTombstoned` {
            return false
        }
        if lhs.`roomTypes` != rhs.`roomTypes` {
            return false
        }
        if lhs.`notRoomTypes` != rhs.`notRoomTypes` {
            return false
        }
        if lhs.`roomNameLike` != rhs.`roomNameLike` {
            return false
        }
        if lhs.`tags` != rhs.`tags` {
            return false
        }
        if lhs.`notTags` != rhs.`notTags` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`isDm`)
        hasher.combine(`spaces`)
        hasher.combine(`isEncrypted`)
        hasher.combine(`isInvite`)
        hasher.combine(`isTombstoned`)
        hasher.combine(`roomTypes`)
        hasher.combine(`notRoomTypes`)
        hasher.combine(`roomNameLike`)
        hasher.combine(`tags`)
        hasher.combine(`notTags`)
    }
}


public struct FfiConverterTypeSlidingSyncRequestListFilters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncRequestListFilters {
        return try SlidingSyncRequestListFilters(
            `isDm`: FfiConverterOptionBool.read(from: &buf),
            `spaces`: FfiConverterSequenceString.read(from: &buf),
            `isEncrypted`: FfiConverterOptionBool.read(from: &buf),
            `isInvite`: FfiConverterOptionBool.read(from: &buf),
            `isTombstoned`: FfiConverterOptionBool.read(from: &buf),
            `roomTypes`: FfiConverterSequenceString.read(from: &buf),
            `notRoomTypes`: FfiConverterSequenceString.read(from: &buf),
            `roomNameLike`: FfiConverterOptionString.read(from: &buf),
            `tags`: FfiConverterSequenceString.read(from: &buf),
            `notTags`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SlidingSyncRequestListFilters, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.`isDm`, into: &buf)
        FfiConverterSequenceString.write(value.`spaces`, into: &buf)
        FfiConverterOptionBool.write(value.`isEncrypted`, into: &buf)
        FfiConverterOptionBool.write(value.`isInvite`, into: &buf)
        FfiConverterOptionBool.write(value.`isTombstoned`, into: &buf)
        FfiConverterSequenceString.write(value.`roomTypes`, into: &buf)
        FfiConverterSequenceString.write(value.`notRoomTypes`, into: &buf)
        FfiConverterOptionString.write(value.`roomNameLike`, into: &buf)
        FfiConverterSequenceString.write(value.`tags`, into: &buf)
        FfiConverterSequenceString.write(value.`notTags`, into: &buf)
    }
}


public func FfiConverterTypeSlidingSyncRequestListFilters_lift(_ buf: RustBuffer) throws -> SlidingSyncRequestListFilters {
    return try FfiConverterTypeSlidingSyncRequestListFilters.lift(buf)
}

public func FfiConverterTypeSlidingSyncRequestListFilters_lower(_ value: SlidingSyncRequestListFilters) -> RustBuffer {
    return FfiConverterTypeSlidingSyncRequestListFilters.lower(value)
}


public struct TextMessageContent {
    public var `body`: String
    public var `formatted`: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `formatted`: FormattedBody?) {
        self.`body` = `body`
        self.`formatted` = `formatted`
    }
}


extension TextMessageContent: Equatable, Hashable {
    public static func ==(lhs: TextMessageContent, rhs: TextMessageContent) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        if lhs.`formatted` != rhs.`formatted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
        hasher.combine(`formatted`)
    }
}


public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return try TextMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `formatted`: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.`formatted`, into: &buf)
    }
}


public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


public struct ThumbnailInfo {
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?) {
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
    }
}


extension ThumbnailInfo: Equatable, Hashable {
    public static func ==(lhs: ThumbnailInfo, rhs: ThumbnailInfo) -> Bool {
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`width` != rhs.`width` {
            return false
        }
        if lhs.`mimetype` != rhs.`mimetype` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`height`)
        hasher.combine(`width`)
        hasher.combine(`mimetype`)
        hasher.combine(`size`)
    }
}


public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return try ThumbnailInfo(
            `height`: FfiConverterOptionUInt64.read(from: &buf),
            `width`: FfiConverterOptionUInt64.read(from: &buf),
            `mimetype`: FfiConverterOptionString.read(from: &buf),
            `size`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
    }
}


public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


public struct UpdateSummary {
    public var `lists`: [String]
    public var `rooms`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lists`: [String], `rooms`: [String]) {
        self.`lists` = `lists`
        self.`rooms` = `rooms`
    }
}


extension UpdateSummary: Equatable, Hashable {
    public static func ==(lhs: UpdateSummary, rhs: UpdateSummary) -> Bool {
        if lhs.`lists` != rhs.`lists` {
            return false
        }
        if lhs.`rooms` != rhs.`rooms` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lists`)
        hasher.combine(`rooms`)
    }
}


public struct FfiConverterTypeUpdateSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateSummary {
        return try UpdateSummary(
            `lists`: FfiConverterSequenceString.read(from: &buf),
            `rooms`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateSummary, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`lists`, into: &buf)
        FfiConverterSequenceString.write(value.`rooms`, into: &buf)
    }
}


public func FfiConverterTypeUpdateSummary_lift(_ buf: RustBuffer) throws -> UpdateSummary {
    return try FfiConverterTypeUpdateSummary.lift(buf)
}

public func FfiConverterTypeUpdateSummary_lower(_ value: UpdateSummary) -> RustBuffer {
    return FfiConverterTypeUpdateSummary.lower(value)
}


public struct UserProfile {
    public var `userId`: String
    public var `displayName`: String?
    public var `avatarUrl`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `displayName`: String?, `avatarUrl`: String?) {
        self.`userId` = `userId`
        self.`displayName` = `displayName`
        self.`avatarUrl` = `avatarUrl`
    }
}


extension UserProfile: Equatable, Hashable {
    public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`displayName` != rhs.`displayName` {
            return false
        }
        if lhs.`avatarUrl` != rhs.`avatarUrl` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`displayName`)
        hasher.combine(`avatarUrl`)
    }
}


public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return try UserProfile(
            `userId`: FfiConverterString.read(from: &buf),
            `displayName`: FfiConverterOptionString.read(from: &buf),
            `avatarUrl`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterOptionString.write(value.`displayName`, into: &buf)
        FfiConverterOptionString.write(value.`avatarUrl`, into: &buf)
    }
}


public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


public struct VideoInfo {
    public var `duration`: UInt64?
    public var `height`: UInt64?
    public var `width`: UInt64?
    public var `mimetype`: String?
    public var `size`: UInt64?
    public var `thumbnailInfo`: ThumbnailInfo?
    public var `thumbnailSource`: MediaSource?
    public var `blurhash`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`duration`: UInt64?, `height`: UInt64?, `width`: UInt64?, `mimetype`: String?, `size`: UInt64?, `thumbnailInfo`: ThumbnailInfo?, `thumbnailSource`: MediaSource?, `blurhash`: String?) {
        self.`duration` = `duration`
        self.`height` = `height`
        self.`width` = `width`
        self.`mimetype` = `mimetype`
        self.`size` = `size`
        self.`thumbnailInfo` = `thumbnailInfo`
        self.`thumbnailSource` = `thumbnailSource`
        self.`blurhash` = `blurhash`
    }
}



public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return try VideoInfo(
            `duration`: FfiConverterOptionUInt64.read(from: &buf),
            `height`: FfiConverterOptionUInt64.read(from: &buf),
            `width`: FfiConverterOptionUInt64.read(from: &buf),
            `mimetype`: FfiConverterOptionString.read(from: &buf),
            `size`: FfiConverterOptionUInt64.read(from: &buf),
            `thumbnailInfo`: FfiConverterOptionTypeThumbnailInfo.read(from: &buf),
            `thumbnailSource`: FfiConverterOptionTypeMediaSource.read(from: &buf),
            `blurhash`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`duration`, into: &buf)
        FfiConverterOptionUInt64.write(value.`height`, into: &buf)
        FfiConverterOptionUInt64.write(value.`width`, into: &buf)
        FfiConverterOptionString.write(value.`mimetype`, into: &buf)
        FfiConverterOptionUInt64.write(value.`size`, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.`thumbnailInfo`, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.`thumbnailSource`, into: &buf)
        FfiConverterOptionString.write(value.`blurhash`, into: &buf)
    }
}


public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    public var `body`: String
    public var `source`: MediaSource
    public var `info`: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String, `source`: MediaSource, `info`: VideoInfo?) {
        self.`body` = `body`
        self.`source` = `source`
        self.`info` = `info`
    }
}



public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return try VideoMessageContent(
            `body`: FfiConverterString.read(from: &buf),
            `source`: FfiConverterTypeMediaSource.read(from: &buf),
            `info`: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
        FfiConverterTypeMediaSource.write(value.`source`, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EncryptedMessage {

    case `olmV1Curve25519AesSha2`(`senderKey`: String)
    case `megolmV1AesSha2`(`sessionId`: String)
    case `unknown`
}

public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`olmV1Curve25519AesSha2`(
            `senderKey`: try FfiConverterString.read(from: &buf)
        )

        case 2: return .`megolmV1AesSha2`(
            `sessionId`: try FfiConverterString.read(from: &buf)
        )

        case 3: return .`unknown`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {


        case let .`olmV1Curve25519AesSha2`(`senderKey`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`senderKey`, into: &buf)


        case let .`megolmV1AesSha2`(`sessionId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`sessionId`, into: &buf)


        case .`unknown`:
            writeInt(&buf, Int32(3))

        }
    }
}


public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


extension EncryptedMessage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventSendState {

    case `notSentYet`
    case `sendingFailed`(`error`: String)
    case `sent`(`eventId`: String)
}

public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`notSentYet`

        case 2: return .`sendingFailed`(
            `error`: try FfiConverterString.read(from: &buf)
        )

        case 3: return .`sent`(
            `eventId`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {


        case .`notSentYet`:
            writeInt(&buf, Int32(1))


        case let .`sendingFailed`(`error`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`error`, into: &buf)


        case let .`sent`(`eventId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`eventId`, into: &buf)

        }
    }
}


public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}


extension EventSendState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {

    case `error`
    case `warn`
    case `info`
    case `debug`
    case `trace`
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`error`

        case 2: return .`warn`

        case 3: return .`info`

        case 4: return .`debug`

        case 5: return .`trace`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {


        case .`error`:
            writeInt(&buf, Int32(1))


        case .`warn`:
            writeInt(&buf, Int32(2))


        case .`info`:
            writeInt(&buf, Int32(3))


        case .`debug`:
            writeInt(&buf, Int32(4))


        case .`trace`:
            writeInt(&buf, Int32(5))

        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Membership {

    case `invited`
    case `joined`
    case `left`
}

public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`invited`

        case 2: return .`joined`

        case 3: return .`left`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {


        case .`invited`:
            writeInt(&buf, Int32(1))


        case .`joined`:
            writeInt(&buf, Int32(2))


        case .`left`:
            writeInt(&buf, Int32(3))

        }
    }
}


public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}


extension Membership: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipChange {

    case `none`
    case `error`
    case `joined`
    case `left`
    case `banned`
    case `unbanned`
    case `kicked`
    case `invited`
    case `kickedAndBanned`
    case `invitationAccepted`
    case `invitationRejected`
    case `invitationRevoked`
    case `knocked`
    case `knockAccepted`
    case `knockRetracted`
    case `knockDenied`
    case `notImplemented`
}

public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`none`

        case 2: return .`error`

        case 3: return .`joined`

        case 4: return .`left`

        case 5: return .`banned`

        case 6: return .`unbanned`

        case 7: return .`kicked`

        case 8: return .`invited`

        case 9: return .`kickedAndBanned`

        case 10: return .`invitationAccepted`

        case 11: return .`invitationRejected`

        case 12: return .`invitationRevoked`

        case 13: return .`knocked`

        case 14: return .`knockAccepted`

        case 15: return .`knockRetracted`

        case 16: return .`knockDenied`

        case 17: return .`notImplemented`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {


        case .`none`:
            writeInt(&buf, Int32(1))


        case .`error`:
            writeInt(&buf, Int32(2))


        case .`joined`:
            writeInt(&buf, Int32(3))


        case .`left`:
            writeInt(&buf, Int32(4))


        case .`banned`:
            writeInt(&buf, Int32(5))


        case .`unbanned`:
            writeInt(&buf, Int32(6))


        case .`kicked`:
            writeInt(&buf, Int32(7))


        case .`invited`:
            writeInt(&buf, Int32(8))


        case .`kickedAndBanned`:
            writeInt(&buf, Int32(9))


        case .`invitationAccepted`:
            writeInt(&buf, Int32(10))


        case .`invitationRejected`:
            writeInt(&buf, Int32(11))


        case .`invitationRevoked`:
            writeInt(&buf, Int32(12))


        case .`knocked`:
            writeInt(&buf, Int32(13))


        case .`knockAccepted`:
            writeInt(&buf, Int32(14))


        case .`knockRetracted`:
            writeInt(&buf, Int32(15))


        case .`knockDenied`:
            writeInt(&buf, Int32(16))


        case .`notImplemented`:
            writeInt(&buf, Int32(17))

        }
    }
}


public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}


extension MembershipChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MembershipState {

    case `ban`
    case `invite`
    case `join`
    case `knock`
    case `leave`
}

public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`ban`

        case 2: return .`invite`

        case 3: return .`join`

        case 4: return .`knock`

        case 5: return .`leave`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {


        case .`ban`:
            writeInt(&buf, Int32(1))


        case .`invite`:
            writeInt(&buf, Int32(2))


        case .`join`:
            writeInt(&buf, Int32(3))


        case .`knock`:
            writeInt(&buf, Int32(4))


        case .`leave`:
            writeInt(&buf, Int32(5))

        }
    }
}


public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}


extension MembershipState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageFormat {

    case `html`
    case `unknown`
}

public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`html`

        case 2: return .`unknown`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {


        case .`html`:
            writeInt(&buf, Int32(1))


        case .`unknown`:
            writeInt(&buf, Int32(2))

        }
    }
}


public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}


extension MessageFormat: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageLikeEventContent {

    case `callAnswer`
    case `callInvite`
    case `callHangup`
    case `callCandidates`
    case `keyVerificationReady`
    case `keyVerificationStart`
    case `keyVerificationCancel`
    case `keyVerificationAccept`
    case `keyVerificationKey`
    case `keyVerificationMac`
    case `keyVerificationDone`
    case `reactionContent`(`relatedEventId`: String)
    case `roomEncrypted`
    case `roomMessage`(`messageType`: MessageType)
    case `roomRedaction`
    case `sticker`
}

public struct FfiConverterTypeMessageLikeEventContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`callAnswer`

        case 2: return .`callInvite`

        case 3: return .`callHangup`

        case 4: return .`callCandidates`

        case 5: return .`keyVerificationReady`

        case 6: return .`keyVerificationStart`

        case 7: return .`keyVerificationCancel`

        case 8: return .`keyVerificationAccept`

        case 9: return .`keyVerificationKey`

        case 10: return .`keyVerificationMac`

        case 11: return .`keyVerificationDone`

        case 12: return .`reactionContent`(
            `relatedEventId`: try FfiConverterString.read(from: &buf)
        )

        case 13: return .`roomEncrypted`

        case 14: return .`roomMessage`(
            `messageType`: try FfiConverterTypeMessageType.read(from: &buf)
        )

        case 15: return .`roomRedaction`

        case 16: return .`sticker`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventContent, into buf: inout [UInt8]) {
        switch value {


        case .`callAnswer`:
            writeInt(&buf, Int32(1))


        case .`callInvite`:
            writeInt(&buf, Int32(2))


        case .`callHangup`:
            writeInt(&buf, Int32(3))


        case .`callCandidates`:
            writeInt(&buf, Int32(4))


        case .`keyVerificationReady`:
            writeInt(&buf, Int32(5))


        case .`keyVerificationStart`:
            writeInt(&buf, Int32(6))


        case .`keyVerificationCancel`:
            writeInt(&buf, Int32(7))


        case .`keyVerificationAccept`:
            writeInt(&buf, Int32(8))


        case .`keyVerificationKey`:
            writeInt(&buf, Int32(9))


        case .`keyVerificationMac`:
            writeInt(&buf, Int32(10))


        case .`keyVerificationDone`:
            writeInt(&buf, Int32(11))


        case let .`reactionContent`(`relatedEventId`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`relatedEventId`, into: &buf)


        case .`roomEncrypted`:
            writeInt(&buf, Int32(13))


        case let .`roomMessage`(`messageType`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeMessageType.write(`messageType`, into: &buf)


        case .`roomRedaction`:
            writeInt(&buf, Int32(15))


        case .`sticker`:
            writeInt(&buf, Int32(16))

        }
    }
}


public func FfiConverterTypeMessageLikeEventContent_lift(_ buf: RustBuffer) throws -> MessageLikeEventContent {
    return try FfiConverterTypeMessageLikeEventContent.lift(buf)
}

public func FfiConverterTypeMessageLikeEventContent_lower(_ value: MessageLikeEventContent) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventContent.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageLikeEventType {

    case `callAnswer`
    case `callInvite`
    case `callHangup`
    case `callCandidates`
    case `keyVerificationReady`
    case `keyVerificationStart`
    case `keyVerificationCancel`
    case `keyVerificationAccept`
    case `keyVerificationKey`
    case `keyVerificationMac`
    case `keyVerificationDone`
    case `reactionSent`
    case `roomEncrypted`
    case `roomMessage`
    case `roomRedaction`
    case `sticker`
}

public struct FfiConverterTypeMessageLikeEventType: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`callAnswer`

        case 2: return .`callInvite`

        case 3: return .`callHangup`

        case 4: return .`callCandidates`

        case 5: return .`keyVerificationReady`

        case 6: return .`keyVerificationStart`

        case 7: return .`keyVerificationCancel`

        case 8: return .`keyVerificationAccept`

        case 9: return .`keyVerificationKey`

        case 10: return .`keyVerificationMac`

        case 11: return .`keyVerificationDone`

        case 12: return .`reactionSent`

        case 13: return .`roomEncrypted`

        case 14: return .`roomMessage`

        case 15: return .`roomRedaction`

        case 16: return .`sticker`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventType, into buf: inout [UInt8]) {
        switch value {


        case .`callAnswer`:
            writeInt(&buf, Int32(1))


        case .`callInvite`:
            writeInt(&buf, Int32(2))


        case .`callHangup`:
            writeInt(&buf, Int32(3))


        case .`callCandidates`:
            writeInt(&buf, Int32(4))


        case .`keyVerificationReady`:
            writeInt(&buf, Int32(5))


        case .`keyVerificationStart`:
            writeInt(&buf, Int32(6))


        case .`keyVerificationCancel`:
            writeInt(&buf, Int32(7))


        case .`keyVerificationAccept`:
            writeInt(&buf, Int32(8))


        case .`keyVerificationKey`:
            writeInt(&buf, Int32(9))


        case .`keyVerificationMac`:
            writeInt(&buf, Int32(10))


        case .`keyVerificationDone`:
            writeInt(&buf, Int32(11))


        case .`reactionSent`:
            writeInt(&buf, Int32(12))


        case .`roomEncrypted`:
            writeInt(&buf, Int32(13))


        case .`roomMessage`:
            writeInt(&buf, Int32(14))


        case .`roomRedaction`:
            writeInt(&buf, Int32(15))


        case .`sticker`:
            writeInt(&buf, Int32(16))

        }
    }
}


public func FfiConverterTypeMessageLikeEventType_lift(_ buf: RustBuffer) throws -> MessageLikeEventType {
    return try FfiConverterTypeMessageLikeEventType.lift(buf)
}

public func FfiConverterTypeMessageLikeEventType_lower(_ value: MessageLikeEventType) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventType.lower(value)
}


extension MessageLikeEventType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MessageType {

    case `emote`(`content`: EmoteMessageContent)
    case `image`(`content`: ImageMessageContent)
    case `audio`(`content`: AudioMessageContent)
    case `video`(`content`: VideoMessageContent)
    case `file`(`content`: FileMessageContent)
    case `notice`(`content`: NoticeMessageContent)
    case `text`(`content`: TextMessageContent)
}

public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`emote`(
            `content`: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )

        case 2: return .`image`(
            `content`: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )

        case 3: return .`audio`(
            `content`: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )

        case 4: return .`video`(
            `content`: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )

        case 5: return .`file`(
            `content`: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )

        case 6: return .`notice`(
            `content`: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )

        case 7: return .`text`(
            `content`: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {


        case let .`emote`(`content`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(`content`, into: &buf)


        case let .`image`(`content`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(`content`, into: &buf)


        case let .`audio`(`content`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(`content`, into: &buf)


        case let .`video`(`content`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(`content`, into: &buf)


        case let .`file`(`content`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(`content`, into: &buf)


        case let .`notice`(`content`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNoticeMessageContent.write(`content`, into: &buf)


        case let .`text`(`content`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTextMessageContent.write(`content`, into: &buf)

        }
    }
}


public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OtherState {

    case `policyRuleRoom`
    case `policyRuleServer`
    case `policyRuleUser`
    case `roomAliases`
    case `roomAvatar`(`url`: String?)
    case `roomCanonicalAlias`
    case `roomCreate`
    case `roomEncryption`
    case `roomGuestAccess`
    case `roomHistoryVisibility`
    case `roomJoinRules`
    case `roomName`(`name`: String?)
    case `roomPinnedEvents`
    case `roomPowerLevels`
    case `roomServerAcl`
    case `roomThirdPartyInvite`(`displayName`: String?)
    case `roomTombstone`
    case `roomTopic`(`topic`: String?)
    case `spaceChild`
    case `spaceParent`
    case `custom`(`eventType`: String)
}

public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`policyRuleRoom`

        case 2: return .`policyRuleServer`

        case 3: return .`policyRuleUser`

        case 4: return .`roomAliases`

        case 5: return .`roomAvatar`(
            `url`: try FfiConverterOptionString.read(from: &buf)
        )

        case 6: return .`roomCanonicalAlias`

        case 7: return .`roomCreate`

        case 8: return .`roomEncryption`

        case 9: return .`roomGuestAccess`

        case 10: return .`roomHistoryVisibility`

        case 11: return .`roomJoinRules`

        case 12: return .`roomName`(
            `name`: try FfiConverterOptionString.read(from: &buf)
        )

        case 13: return .`roomPinnedEvents`

        case 14: return .`roomPowerLevels`

        case 15: return .`roomServerAcl`

        case 16: return .`roomThirdPartyInvite`(
            `displayName`: try FfiConverterOptionString.read(from: &buf)
        )

        case 17: return .`roomTombstone`

        case 18: return .`roomTopic`(
            `topic`: try FfiConverterOptionString.read(from: &buf)
        )

        case 19: return .`spaceChild`

        case 20: return .`spaceParent`

        case 21: return .`custom`(
            `eventType`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {


        case .`policyRuleRoom`:
            writeInt(&buf, Int32(1))


        case .`policyRuleServer`:
            writeInt(&buf, Int32(2))


        case .`policyRuleUser`:
            writeInt(&buf, Int32(3))


        case .`roomAliases`:
            writeInt(&buf, Int32(4))


        case let .`roomAvatar`(`url`):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(`url`, into: &buf)


        case .`roomCanonicalAlias`:
            writeInt(&buf, Int32(6))


        case .`roomCreate`:
            writeInt(&buf, Int32(7))


        case .`roomEncryption`:
            writeInt(&buf, Int32(8))


        case .`roomGuestAccess`:
            writeInt(&buf, Int32(9))


        case .`roomHistoryVisibility`:
            writeInt(&buf, Int32(10))


        case .`roomJoinRules`:
            writeInt(&buf, Int32(11))


        case let .`roomName`(`name`):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(`name`, into: &buf)


        case .`roomPinnedEvents`:
            writeInt(&buf, Int32(13))


        case .`roomPowerLevels`:
            writeInt(&buf, Int32(14))


        case .`roomServerAcl`:
            writeInt(&buf, Int32(15))


        case let .`roomThirdPartyInvite`(`displayName`):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(`displayName`, into: &buf)


        case .`roomTombstone`:
            writeInt(&buf, Int32(17))


        case let .`roomTopic`(`topic`):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(`topic`, into: &buf)


        case .`spaceChild`:
            writeInt(&buf, Int32(19))


        case .`spaceParent`:
            writeInt(&buf, Int32(20))


        case let .`custom`(`eventType`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`eventType`, into: &buf)

        }
    }
}


public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}


extension OtherState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaginationOptions {

    case `singleRequest`(`eventLimit`: UInt16)
    case `untilNumItems`(`eventLimit`: UInt16, `items`: UInt16)
}

public struct FfiConverterTypePaginationOptions: FfiConverterRustBuffer {
    typealias SwiftType = PaginationOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaginationOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`singleRequest`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf)
        )

        case 2: return .`untilNumItems`(
            `eventLimit`: try FfiConverterUInt16.read(from: &buf),
            `items`: try FfiConverterUInt16.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaginationOptions, into buf: inout [UInt8]) {
        switch value {


        case let .`singleRequest`(`eventLimit`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)


        case let .`untilNumItems`(`eventLimit`,`items`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(`eventLimit`, into: &buf)
            FfiConverterUInt16.write(`items`, into: &buf)

        }
    }
}


public func FfiConverterTypePaginationOptions_lift(_ buf: RustBuffer) throws -> PaginationOptions {
    return try FfiConverterTypePaginationOptions.lift(buf)
}

public func FfiConverterTypePaginationOptions_lower(_ value: PaginationOptions) -> RustBuffer {
    return FfiConverterTypePaginationOptions.lower(value)
}


extension PaginationOptions: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ProfileDetails {

    case `unavailable`
    case `pending`
    case `ready`(`displayName`: String?, `displayNameAmbiguous`: Bool, `avatarUrl`: String?)
    case `error`(`message`: String)
}

public struct FfiConverterTypeProfileDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`unavailable`

        case 2: return .`pending`

        case 3: return .`ready`(
            `displayName`: try FfiConverterOptionString.read(from: &buf),
            `displayNameAmbiguous`: try FfiConverterBool.read(from: &buf),
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )

        case 4: return .`error`(
            `message`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileDetails, into buf: inout [UInt8]) {
        switch value {


        case .`unavailable`:
            writeInt(&buf, Int32(1))


        case .`pending`:
            writeInt(&buf, Int32(2))


        case let .`ready`(`displayName`,`displayNameAmbiguous`,`avatarUrl`):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterBool.write(`displayNameAmbiguous`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)


        case let .`error`(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)

        }
    }
}


public func FfiConverterTypeProfileDetails_lift(_ buf: RustBuffer) throws -> ProfileDetails {
    return try FfiConverterTypeProfileDetails.lift(buf)
}

public func FfiConverterTypeProfileDetails_lower(_ value: ProfileDetails) -> RustBuffer {
    return FfiConverterTypeProfileDetails.lower(value)
}


extension ProfileDetails: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PushFormat {

    case `eventIdOnly`
}

public struct FfiConverterTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`eventIdOnly`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushFormat, into buf: inout [UInt8]) {
        switch value {


        case .`eventIdOnly`:
            writeInt(&buf, Int32(1))

        }
    }
}


public func FfiConverterTypePushFormat_lift(_ buf: RustBuffer) throws -> PushFormat {
    return try FfiConverterTypePushFormat.lift(buf)
}

public func FfiConverterTypePushFormat_lower(_ value: PushFormat) -> RustBuffer {
    return FfiConverterTypePushFormat.lower(value)
}


extension PushFormat: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PusherKind {

    case `http`(`data`: HttpPusherData)
    case `email`
}

public struct FfiConverterTypePusherKind: FfiConverterRustBuffer {
    typealias SwiftType = PusherKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`http`(
            `data`: try FfiConverterTypeHttpPusherData.read(from: &buf)
        )

        case 2: return .`email`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PusherKind, into buf: inout [UInt8]) {
        switch value {


        case let .`http`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHttpPusherData.write(`data`, into: &buf)


        case .`email`:
            writeInt(&buf, Int32(2))

        }
    }
}


public func FfiConverterTypePusherKind_lift(_ buf: RustBuffer) throws -> PusherKind {
    return try FfiConverterTypePusherKind.lift(buf)
}

public func FfiConverterTypePusherKind_lower(_ value: PusherKind) -> RustBuffer {
    return FfiConverterTypePusherKind.lower(value)
}


extension PusherKind: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RepliedToEventDetails {

    case `unavailable`
    case `pending`
    case `ready`(`message`: Message, `sender`: String, `senderProfile`: ProfileDetails)
    case `error`(`message`: String)
}

public struct FfiConverterTypeRepliedToEventDetails: FfiConverterRustBuffer {
    typealias SwiftType = RepliedToEventDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RepliedToEventDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`unavailable`

        case 2: return .`pending`

        case 3: return .`ready`(
            `message`: try FfiConverterTypeMessage.read(from: &buf),
            `sender`: try FfiConverterString.read(from: &buf),
            `senderProfile`: try FfiConverterTypeProfileDetails.read(from: &buf)
        )

        case 4: return .`error`(
            `message`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RepliedToEventDetails, into buf: inout [UInt8]) {
        switch value {


        case .`unavailable`:
            writeInt(&buf, Int32(1))


        case .`pending`:
            writeInt(&buf, Int32(2))


        case let .`ready`(`message`,`sender`,`senderProfile`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMessage.write(`message`, into: &buf)
            FfiConverterString.write(`sender`, into: &buf)
            FfiConverterTypeProfileDetails.write(`senderProfile`, into: &buf)


        case let .`error`(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)

        }
    }
}


public func FfiConverterTypeRepliedToEventDetails_lift(_ buf: RustBuffer) throws -> RepliedToEventDetails {
    return try FfiConverterTypeRepliedToEventDetails.lift(buf)
}

public func FfiConverterTypeRepliedToEventDetails_lower(_ value: RepliedToEventDetails) -> RustBuffer {
    return FfiConverterTypeRepliedToEventDetails.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomListEntry {

    case `empty`
    case `invalidated`(`roomId`: String)
    case `filled`(`roomId`: String)
}

public struct FfiConverterTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntry {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`empty`

        case 2: return .`invalidated`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )

        case 3: return .`filled`(
            `roomId`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntry, into buf: inout [UInt8]) {
        switch value {


        case .`empty`:
            writeInt(&buf, Int32(1))


        case let .`invalidated`(`roomId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`roomId`, into: &buf)


        case let .`filled`(`roomId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`roomId`, into: &buf)

        }
    }
}


public func FfiConverterTypeRoomListEntry_lift(_ buf: RustBuffer) throws -> RoomListEntry {
    return try FfiConverterTypeRoomListEntry.lift(buf)
}

public func FfiConverterTypeRoomListEntry_lower(_ value: RoomListEntry) -> RustBuffer {
    return FfiConverterTypeRoomListEntry.lower(value)
}


extension RoomListEntry: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomPreset {

    case `privateChat`
    case `publicChat`
    case `trustedPrivateChat`
}

public struct FfiConverterTypeRoomPreset: FfiConverterRustBuffer {
    typealias SwiftType = RoomPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`privateChat`

        case 2: return .`publicChat`

        case 3: return .`trustedPrivateChat`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomPreset, into buf: inout [UInt8]) {
        switch value {


        case .`privateChat`:
            writeInt(&buf, Int32(1))


        case .`publicChat`:
            writeInt(&buf, Int32(2))


        case .`trustedPrivateChat`:
            writeInt(&buf, Int32(3))

        }
    }
}


public func FfiConverterTypeRoomPreset_lift(_ buf: RustBuffer) throws -> RoomPreset {
    return try FfiConverterTypeRoomPreset.lift(buf)
}

public func FfiConverterTypeRoomPreset_lower(_ value: RoomPreset) -> RustBuffer {
    return FfiConverterTypeRoomPreset.lower(value)
}


extension RoomPreset: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RoomVisibility {

    case `public`
    case `private`
}

public struct FfiConverterTypeRoomVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`public`

        case 2: return .`private`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomVisibility, into buf: inout [UInt8]) {
        switch value {


        case .`public`:
            writeInt(&buf, Int32(1))


        case .`private`:
            writeInt(&buf, Int32(2))

        }
    }
}


public func FfiConverterTypeRoomVisibility_lift(_ buf: RustBuffer) throws -> RoomVisibility {
    return try FfiConverterTypeRoomVisibility.lift(buf)
}

public func FfiConverterTypeRoomVisibility_lower(_ value: RoomVisibility) -> RustBuffer {
    return FfiConverterTypeRoomVisibility.lower(value)
}


extension RoomVisibility: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncListRoomsListDiff {

    case `append`(`values`: [RoomListEntry])
    case `insert`(`index`: UInt32, `value`: RoomListEntry)
    case `set`(`index`: UInt32, `value`: RoomListEntry)
    case `remove`(`index`: UInt32)
    case `pushBack`(`value`: RoomListEntry)
    case `pushFront`(`value`: RoomListEntry)
    case `popBack`
    case `popFront`
    case `clear`
    case `reset`(`values`: [RoomListEntry])
}

public struct FfiConverterTypeSlidingSyncListRoomsListDiff: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncListRoomsListDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncListRoomsListDiff {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`append`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )

        case 2: return .`insert`(
            `index`: try FfiConverterUInt32.read(from: &buf),
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )

        case 3: return .`set`(
            `index`: try FfiConverterUInt32.read(from: &buf),
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )

        case 4: return .`remove`(
            `index`: try FfiConverterUInt32.read(from: &buf)
        )

        case 5: return .`pushBack`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )

        case 6: return .`pushFront`(
            `value`: try FfiConverterTypeRoomListEntry.read(from: &buf)
        )

        case 7: return .`popBack`

        case 8: return .`popFront`

        case 9: return .`clear`

        case 10: return .`reset`(
            `values`: try FfiConverterSequenceTypeRoomListEntry.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncListRoomsListDiff, into buf: inout [UInt8]) {
        switch value {


        case let .`append`(`values`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)


        case let .`insert`(`index`,`value`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)


        case let .`set`(`index`,`value`):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(`index`, into: &buf)
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)


        case let .`remove`(`index`):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(`index`, into: &buf)


        case let .`pushBack`(`value`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)


        case let .`pushFront`(`value`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeRoomListEntry.write(`value`, into: &buf)


        case .`popBack`:
            writeInt(&buf, Int32(7))


        case .`popFront`:
            writeInt(&buf, Int32(8))


        case .`clear`:
            writeInt(&buf, Int32(9))


        case let .`reset`(`values`):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeRoomListEntry.write(`values`, into: &buf)

        }
    }
}


public func FfiConverterTypeSlidingSyncListRoomsListDiff_lift(_ buf: RustBuffer) throws -> SlidingSyncListRoomsListDiff {
    return try FfiConverterTypeSlidingSyncListRoomsListDiff.lift(buf)
}

public func FfiConverterTypeSlidingSyncListRoomsListDiff_lower(_ value: SlidingSyncListRoomsListDiff) -> RustBuffer {
    return FfiConverterTypeSlidingSyncListRoomsListDiff.lower(value)
}


extension SlidingSyncListRoomsListDiff: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SlidingSyncState {

    case `notLoaded`
    case `preloaded`
    case `partiallyLoaded`
    case `fullyLoaded`
}

public struct FfiConverterTypeSlidingSyncState: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncState {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`notLoaded`

        case 2: return .`preloaded`

        case 3: return .`partiallyLoaded`

        case 4: return .`fullyLoaded`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncState, into buf: inout [UInt8]) {
        switch value {


        case .`notLoaded`:
            writeInt(&buf, Int32(1))


        case .`preloaded`:
            writeInt(&buf, Int32(2))


        case .`partiallyLoaded`:
            writeInt(&buf, Int32(3))


        case .`fullyLoaded`:
            writeInt(&buf, Int32(4))

        }
    }
}


public func FfiConverterTypeSlidingSyncState_lift(_ buf: RustBuffer) throws -> SlidingSyncState {
    return try FfiConverterTypeSlidingSyncState.lift(buf)
}

public func FfiConverterTypeSlidingSyncState_lower(_ value: SlidingSyncState) -> RustBuffer {
    return FfiConverterTypeSlidingSyncState.lower(value)
}


extension SlidingSyncState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum StateEventContent {

    case `policyRuleRoom`
    case `policyRuleServer`
    case `policyRuleUser`
    case `roomAliases`
    case `roomAvatar`
    case `roomCanonicalAlias`
    case `roomCreate`
    case `roomEncryption`
    case `roomGuestAccess`
    case `roomHistoryVisibility`
    case `roomJoinRules`
    case `roomMemberContent`(`userId`: String, `membershipState`: MembershipState)
    case `roomName`
    case `roomPinnedEvents`
    case `roomPowerLevels`
    case `roomServerAcl`
    case `roomThirdPartyInvite`
    case `roomTombstone`
    case `roomTopic`
    case `spaceChild`
    case `spaceParent`
}

public struct FfiConverterTypeStateEventContent: FfiConverterRustBuffer {
    typealias SwiftType = StateEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`policyRuleRoom`

        case 2: return .`policyRuleServer`

        case 3: return .`policyRuleUser`

        case 4: return .`roomAliases`

        case 5: return .`roomAvatar`

        case 6: return .`roomCanonicalAlias`

        case 7: return .`roomCreate`

        case 8: return .`roomEncryption`

        case 9: return .`roomGuestAccess`

        case 10: return .`roomHistoryVisibility`

        case 11: return .`roomJoinRules`

        case 12: return .`roomMemberContent`(
            `userId`: try FfiConverterString.read(from: &buf),
            `membershipState`: try FfiConverterTypeMembershipState.read(from: &buf)
        )

        case 13: return .`roomName`

        case 14: return .`roomPinnedEvents`

        case 15: return .`roomPowerLevels`

        case 16: return .`roomServerAcl`

        case 17: return .`roomThirdPartyInvite`

        case 18: return .`roomTombstone`

        case 19: return .`roomTopic`

        case 20: return .`spaceChild`

        case 21: return .`spaceParent`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventContent, into buf: inout [UInt8]) {
        switch value {


        case .`policyRuleRoom`:
            writeInt(&buf, Int32(1))


        case .`policyRuleServer`:
            writeInt(&buf, Int32(2))


        case .`policyRuleUser`:
            writeInt(&buf, Int32(3))


        case .`roomAliases`:
            writeInt(&buf, Int32(4))


        case .`roomAvatar`:
            writeInt(&buf, Int32(5))


        case .`roomCanonicalAlias`:
            writeInt(&buf, Int32(6))


        case .`roomCreate`:
            writeInt(&buf, Int32(7))


        case .`roomEncryption`:
            writeInt(&buf, Int32(8))


        case .`roomGuestAccess`:
            writeInt(&buf, Int32(9))


        case .`roomHistoryVisibility`:
            writeInt(&buf, Int32(10))


        case .`roomJoinRules`:
            writeInt(&buf, Int32(11))


        case let .`roomMemberContent`(`userId`,`membershipState`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterTypeMembershipState.write(`membershipState`, into: &buf)


        case .`roomName`:
            writeInt(&buf, Int32(13))


        case .`roomPinnedEvents`:
            writeInt(&buf, Int32(14))


        case .`roomPowerLevels`:
            writeInt(&buf, Int32(15))


        case .`roomServerAcl`:
            writeInt(&buf, Int32(16))


        case .`roomThirdPartyInvite`:
            writeInt(&buf, Int32(17))


        case .`roomTombstone`:
            writeInt(&buf, Int32(18))


        case .`roomTopic`:
            writeInt(&buf, Int32(19))


        case .`spaceChild`:
            writeInt(&buf, Int32(20))


        case .`spaceParent`:
            writeInt(&buf, Int32(21))

        }
    }
}


public func FfiConverterTypeStateEventContent_lift(_ buf: RustBuffer) throws -> StateEventContent {
    return try FfiConverterTypeStateEventContent.lift(buf)
}

public func FfiConverterTypeStateEventContent_lower(_ value: StateEventContent) -> RustBuffer {
    return FfiConverterTypeStateEventContent.lower(value)
}


extension StateEventContent: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum StateEventType {

    case `policyRuleRoom`
    case `policyRuleServer`
    case `policyRuleUser`
    case `roomAliases`
    case `roomAvatar`
    case `roomCanonicalAlias`
    case `roomCreate`
    case `roomEncryption`
    case `roomGuestAccess`
    case `roomHistoryVisibility`
    case `roomJoinRules`
    case `roomMemberEvent`
    case `roomName`
    case `roomPinnedEvents`
    case `roomPowerLevels`
    case `roomServerAcl`
    case `roomThirdPartyInvite`
    case `roomTombstone`
    case `roomTopic`
    case `spaceChild`
    case `spaceParent`
}

public struct FfiConverterTypeStateEventType: FfiConverterRustBuffer {
    typealias SwiftType = StateEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`policyRuleRoom`

        case 2: return .`policyRuleServer`

        case 3: return .`policyRuleUser`

        case 4: return .`roomAliases`

        case 5: return .`roomAvatar`

        case 6: return .`roomCanonicalAlias`

        case 7: return .`roomCreate`

        case 8: return .`roomEncryption`

        case 9: return .`roomGuestAccess`

        case 10: return .`roomHistoryVisibility`

        case 11: return .`roomJoinRules`

        case 12: return .`roomMemberEvent`

        case 13: return .`roomName`

        case 14: return .`roomPinnedEvents`

        case 15: return .`roomPowerLevels`

        case 16: return .`roomServerAcl`

        case 17: return .`roomThirdPartyInvite`

        case 18: return .`roomTombstone`

        case 19: return .`roomTopic`

        case 20: return .`spaceChild`

        case 21: return .`spaceParent`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventType, into buf: inout [UInt8]) {
        switch value {


        case .`policyRuleRoom`:
            writeInt(&buf, Int32(1))


        case .`policyRuleServer`:
            writeInt(&buf, Int32(2))


        case .`policyRuleUser`:
            writeInt(&buf, Int32(3))


        case .`roomAliases`:
            writeInt(&buf, Int32(4))


        case .`roomAvatar`:
            writeInt(&buf, Int32(5))


        case .`roomCanonicalAlias`:
            writeInt(&buf, Int32(6))


        case .`roomCreate`:
            writeInt(&buf, Int32(7))


        case .`roomEncryption`:
            writeInt(&buf, Int32(8))


        case .`roomGuestAccess`:
            writeInt(&buf, Int32(9))


        case .`roomHistoryVisibility`:
            writeInt(&buf, Int32(10))


        case .`roomJoinRules`:
            writeInt(&buf, Int32(11))


        case .`roomMemberEvent`:
            writeInt(&buf, Int32(12))


        case .`roomName`:
            writeInt(&buf, Int32(13))


        case .`roomPinnedEvents`:
            writeInt(&buf, Int32(14))


        case .`roomPowerLevels`:
            writeInt(&buf, Int32(15))


        case .`roomServerAcl`:
            writeInt(&buf, Int32(16))


        case .`roomThirdPartyInvite`:
            writeInt(&buf, Int32(17))


        case .`roomTombstone`:
            writeInt(&buf, Int32(18))


        case .`roomTopic`:
            writeInt(&buf, Int32(19))


        case .`spaceChild`:
            writeInt(&buf, Int32(20))


        case .`spaceParent`:
            writeInt(&buf, Int32(21))

        }
    }
}


public func FfiConverterTypeStateEventType_lift(_ buf: RustBuffer) throws -> StateEventType {
    return try FfiConverterTypeStateEventType.lift(buf)
}

public func FfiConverterTypeStateEventType_lower(_ value: StateEventType) -> RustBuffer {
    return FfiConverterTypeStateEventType.lower(value)
}


extension StateEventType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineChange {

    case `append`
    case `clear`
    case `insert`
    case `set`
    case `remove`
    case `pushBack`
    case `pushFront`
    case `popBack`
    case `popFront`
    case `reset`
}

public struct FfiConverterTypeTimelineChange: FfiConverterRustBuffer {
    typealias SwiftType = TimelineChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`append`

        case 2: return .`clear`

        case 3: return .`insert`

        case 4: return .`set`

        case 5: return .`remove`

        case 6: return .`pushBack`

        case 7: return .`pushFront`

        case 8: return .`popBack`

        case 9: return .`popFront`

        case 10: return .`reset`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineChange, into buf: inout [UInt8]) {
        switch value {


        case .`append`:
            writeInt(&buf, Int32(1))


        case .`clear`:
            writeInt(&buf, Int32(2))


        case .`insert`:
            writeInt(&buf, Int32(3))


        case .`set`:
            writeInt(&buf, Int32(4))


        case .`remove`:
            writeInt(&buf, Int32(5))


        case .`pushBack`:
            writeInt(&buf, Int32(6))


        case .`pushFront`:
            writeInt(&buf, Int32(7))


        case .`popBack`:
            writeInt(&buf, Int32(8))


        case .`popFront`:
            writeInt(&buf, Int32(9))


        case .`reset`:
            writeInt(&buf, Int32(10))

        }
    }
}


public func FfiConverterTypeTimelineChange_lift(_ buf: RustBuffer) throws -> TimelineChange {
    return try FfiConverterTypeTimelineChange.lift(buf)
}

public func FfiConverterTypeTimelineChange_lower(_ value: TimelineChange) -> RustBuffer {
    return FfiConverterTypeTimelineChange.lower(value)
}


extension TimelineChange: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineEventType {

    case `messageLike`(`content`: MessageLikeEventContent)
    case `state`(`content`: StateEventContent)
}

public struct FfiConverterTypeTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`messageLike`(
            `content`: try FfiConverterTypeMessageLikeEventContent.read(from: &buf)
        )

        case 2: return .`state`(
            `content`: try FfiConverterTypeStateEventContent.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineEventType, into buf: inout [UInt8]) {
        switch value {


        case let .`messageLike`(`content`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventContent.write(`content`, into: &buf)


        case let .`state`(`content`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventContent.write(`content`, into: &buf)

        }
    }
}


public func FfiConverterTypeTimelineEventType_lift(_ buf: RustBuffer) throws -> TimelineEventType {
    return try FfiConverterTypeTimelineEventType.lift(buf)
}

public func FfiConverterTypeTimelineEventType_lower(_ value: TimelineEventType) -> RustBuffer {
    return FfiConverterTypeTimelineEventType.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TimelineItemContentKind {

    case `message`
    case `redactedMessage`
    case `sticker`(`body`: String, `info`: ImageInfo, `url`: String)
    case `unableToDecrypt`(`msg`: EncryptedMessage)
    case `roomMembership`(`userId`: String, `change`: MembershipChange?)
    case `profileChange`(`displayName`: String?, `prevDisplayName`: String?, `avatarUrl`: String?, `prevAvatarUrl`: String?)
    case `state`(`stateKey`: String, `content`: OtherState)
    case `failedToParseMessageLike`(`eventType`: String, `error`: String)
    case `failedToParseState`(`eventType`: String, `stateKey`: String, `error`: String)
}

public struct FfiConverterTypeTimelineItemContentKind: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`message`

        case 2: return .`redactedMessage`

        case 3: return .`sticker`(
            `body`: try FfiConverterString.read(from: &buf),
            `info`: try FfiConverterTypeImageInfo.read(from: &buf),
            `url`: try FfiConverterString.read(from: &buf)
        )

        case 4: return .`unableToDecrypt`(
            `msg`: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )

        case 5: return .`roomMembership`(
            `userId`: try FfiConverterString.read(from: &buf),
            `change`: try FfiConverterOptionTypeMembershipChange.read(from: &buf)
        )

        case 6: return .`profileChange`(
            `displayName`: try FfiConverterOptionString.read(from: &buf),
            `prevDisplayName`: try FfiConverterOptionString.read(from: &buf),
            `avatarUrl`: try FfiConverterOptionString.read(from: &buf),
            `prevAvatarUrl`: try FfiConverterOptionString.read(from: &buf)
        )

        case 7: return .`state`(
            `stateKey`: try FfiConverterString.read(from: &buf),
            `content`: try FfiConverterTypeOtherState.read(from: &buf)
        )

        case 8: return .`failedToParseMessageLike`(
            `eventType`: try FfiConverterString.read(from: &buf),
            `error`: try FfiConverterString.read(from: &buf)
        )

        case 9: return .`failedToParseState`(
            `eventType`: try FfiConverterString.read(from: &buf),
            `stateKey`: try FfiConverterString.read(from: &buf),
            `error`: try FfiConverterString.read(from: &buf)
        )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContentKind, into buf: inout [UInt8]) {
        switch value {


        case .`message`:
            writeInt(&buf, Int32(1))


        case .`redactedMessage`:
            writeInt(&buf, Int32(2))


        case let .`sticker`(`body`,`info`,`url`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`body`, into: &buf)
            FfiConverterTypeImageInfo.write(`info`, into: &buf)
            FfiConverterString.write(`url`, into: &buf)


        case let .`unableToDecrypt`(`msg`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEncryptedMessage.write(`msg`, into: &buf)


        case let .`roomMembership`(`userId`,`change`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(`change`, into: &buf)


        case let .`profileChange`(`displayName`,`prevDisplayName`,`avatarUrl`,`prevAvatarUrl`):
            writeInt(&buf, Int32(6))
            FfiConverterOptionString.write(`displayName`, into: &buf)
            FfiConverterOptionString.write(`prevDisplayName`, into: &buf)
            FfiConverterOptionString.write(`avatarUrl`, into: &buf)
            FfiConverterOptionString.write(`prevAvatarUrl`, into: &buf)


        case let .`state`(`stateKey`,`content`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterTypeOtherState.write(`content`, into: &buf)


        case let .`failedToParseMessageLike`(`eventType`,`error`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)


        case let .`failedToParseState`(`eventType`,`stateKey`,`error`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`stateKey`, into: &buf)
            FfiConverterString.write(`error`, into: &buf)

        }
    }
}


public func FfiConverterTypeTimelineItemContentKind_lift(_ buf: RustBuffer) throws -> TimelineItemContentKind {
    return try FfiConverterTypeTimelineItemContentKind.lift(buf)
}

public func FfiConverterTypeTimelineItemContentKind_lower(_ value: TimelineItemContentKind) -> RustBuffer {
    return FfiConverterTypeTimelineItemContentKind.lower(value)
}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VirtualTimelineItem {

    case `dayDivider`(`ts`: UInt64)
    case `readMarker`
    case `loadingIndicator`
    case `timelineStart`
}

public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        case 1: return .`dayDivider`(
            `ts`: try FfiConverterUInt64.read(from: &buf)
        )

        case 2: return .`readMarker`

        case 3: return .`loadingIndicator`

        case 4: return .`timelineStart`

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {


        case let .`dayDivider`(`ts`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`ts`, into: &buf)


        case .`readMarker`:
            writeInt(&buf, Int32(2))


        case .`loadingIndicator`:
            writeInt(&buf, Int32(3))


        case .`timelineStart`:
            writeInt(&buf, Int32(4))

        }
    }
}


public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}


extension VirtualTimelineItem: Equatable, Hashable {}



public enum AuthenticationError {



    // Simple error enums only carry a message
    case ClientMissing(message: String)

    // Simple error enums only carry a message
    case InvalidServerName(message: String)

    // Simple error enums only carry a message
    case SlidingSyncNotAvailable(message: String)

    // Simple error enums only carry a message
    case SessionMissing(message: String)

    // Simple error enums only carry a message
    case Generic(message: String)

}

public struct FfiConverterTypeAuthenticationError: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {




        case 1: return .ClientMissing(
            message: try FfiConverterString.read(from: &buf)
        )

        case 2: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )

        case 3: return .SlidingSyncNotAvailable(
            message: try FfiConverterString.read(from: &buf)
        )

        case 4: return .SessionMissing(
            message: try FfiConverterString.read(from: &buf)
        )

        case 5: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )


        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthenticationError, into buf: inout [UInt8]) {
        switch value {




        case let .ClientMissing(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidServerName(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .SlidingSyncNotAvailable(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .SessionMissing(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .Generic(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)


        }
    }
}


extension AuthenticationError: Equatable, Hashable {}

extension AuthenticationError: Error { }


public enum ClientError {



    case Generic(`msg`: String)
}

public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {




        case 1: return .Generic(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {





        case let .Generic(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)

        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }


public enum RoomError {



    // Simple error enums only carry a message
    case InvalidAttachmentData(message: String)

    // Simple error enums only carry a message
    case InvalidAttachmentMimeType(message: String)

    // Simple error enums only carry a message
    case TimelineUnavailable(message: String)

    // Simple error enums only carry a message
    case InvalidThumbnailData(message: String)

    // Simple error enums only carry a message
    case FailedSendingAttachment(message: String)

}

public struct FfiConverterTypeRoomError: FfiConverterRustBuffer {
    typealias SwiftType = RoomError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomError {
        let variant: Int32 = try readInt(&buf)
        switch variant {




        case 1: return .InvalidAttachmentData(
            message: try FfiConverterString.read(from: &buf)
        )

        case 2: return .InvalidAttachmentMimeType(
            message: try FfiConverterString.read(from: &buf)
        )

        case 3: return .TimelineUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )

        case 4: return .InvalidThumbnailData(
            message: try FfiConverterString.read(from: &buf)
        )

        case 5: return .FailedSendingAttachment(
            message: try FfiConverterString.read(from: &buf)
        )


        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomError, into buf: inout [UInt8]) {
        switch value {




        case let .InvalidAttachmentData(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAttachmentMimeType(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .TimelineUnavailable(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidThumbnailData(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .FailedSendingAttachment(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)


        }
    }
}


extension RoomError: Equatable, Hashable {}

extension RoomError: Error { }


public enum SlidingSyncError {



    case BadResponse(`msg`: String)
    case BuildMissingField(`msg`: String)
    case RequestGeneratorHasNotBeenInitialized(`msg`: String)
    case CannotModifyRanges(`msg`: String)
    case InvalidRange(`start`: UInt32, `end`: UInt32)
    case InternalChannelIsBroken
    case Unknown(`error`: String)
}

public struct FfiConverterTypeSlidingSyncError: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncError {
        let variant: Int32 = try readInt(&buf)
        switch variant {




        case 1: return .BadResponse(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .BuildMissingField(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .RequestGeneratorHasNotBeenInitialized(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 4: return .CannotModifyRanges(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidRange(
            `start`: try FfiConverterUInt32.read(from: &buf),
            `end`: try FfiConverterUInt32.read(from: &buf)
            )
        case 6: return .InternalChannelIsBroken
        case 7: return .Unknown(
            `error`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncError, into buf: inout [UInt8]) {
        switch value {





        case let .BadResponse(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)


        case let .BuildMissingField(`msg`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`msg`, into: &buf)


        case let .RequestGeneratorHasNotBeenInitialized(`msg`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`msg`, into: &buf)


        case let .CannotModifyRanges(`msg`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`msg`, into: &buf)


        case let .InvalidRange(`start`,`end`):
            writeInt(&buf, Int32(5))
            FfiConverterUInt32.write(`start`, into: &buf)
            FfiConverterUInt32.write(`end`, into: &buf)


        case .InternalChannelIsBroken:
            writeInt(&buf, Int32(6))


        case let .Unknown(`error`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`error`, into: &buf)

        }
    }
}


extension SlidingSyncError: Equatable, Hashable {}

extension SlidingSyncError: Error { }


public enum TimelineError {



    // Simple error enums only carry a message
    case MissingMediaInfoField(message: String)

    // Simple error enums only carry a message
    case InvalidMediaInfoField(message: String)

}

public struct FfiConverterTypeTimelineError: FfiConverterRustBuffer {
    typealias SwiftType = TimelineError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineError {
        let variant: Int32 = try readInt(&buf)
        switch variant {




        case 1: return .MissingMediaInfoField(
            message: try FfiConverterString.read(from: &buf)
        )

        case 2: return .InvalidMediaInfoField(
            message: try FfiConverterString.read(from: &buf)
        )


        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineError, into buf: inout [UInt8]) {
        switch value {




        case let .MissingMediaInfoField(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidMediaInfoField(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)


        }
    }
}


extension TimelineError: Equatable, Hashable {}

extension TimelineError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for ClientDelegate Callback Interface

public protocol ClientDelegate : AnyObject {
    func `didReceiveAuthError`(`isSoftLogout`: Bool)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceClientDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveAuthError`(_ swiftCallbackInterface: ClientDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveAuthError`(
                    `isSoftLogout`:  try FfiConverterBool.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceClientDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ClientDelegate
            do {
                cb = try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ClientDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveAuthError`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_clientdelegate(foreignCallbackCallbackInterfaceClientDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ClientDelegate>()
}

extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for NotificationDelegate Callback Interface

public protocol NotificationDelegate : AnyObject {
    func `didReceiveNotification`(`notification`: NotificationItem)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceNotificationDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveNotification`(_ swiftCallbackInterface: NotificationDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveNotification`(
                    `notification`:  try FfiConverterTypeNotificationItem.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceNotificationDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: NotificationDelegate
            do {
                cb = try FfiConverterCallbackInterfaceNotificationDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("NotificationDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveNotification`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNotificationDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_notificationdelegate(foreignCallbackCallbackInterfaceNotificationDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<NotificationDelegate>()
}

extension FfiConverterCallbackInterfaceNotificationDelegate : FfiConverter {
    typealias SwiftType = NotificationDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SessionVerificationControllerDelegate Callback Interface

public protocol SessionVerificationControllerDelegate : AnyObject {
    func `didAcceptVerificationRequest`()
    func `didStartSasVerification`()
    func `didReceiveVerificationData`(`data`: [SessionVerificationEmoji])
    func `didFail`()
    func `didCancel`()
    func `didFinish`()

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidAcceptVerificationRequest`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didAcceptVerificationRequest`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidStartSasVerification`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didStartSasVerification`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidReceiveVerificationData`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveVerificationData`(
                    `data`:  try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidFail`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didFail`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidCancel`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didCancel`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDidFinish`(_ swiftCallbackInterface: SessionVerificationControllerDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didFinish`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidAcceptVerificationRequest`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidStartSasVerification`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveVerificationData`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidFail`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 5:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidCancel`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 6:
            let cb: SessionVerificationControllerDelegate
            do {
                cb = try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SessionVerificationControllerDelegate: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidFinish`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_sessionverificationcontrollerdelegate(foreignCallbackCallbackInterfaceSessionVerificationControllerDelegate, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SessionVerificationControllerDelegate>()
}

extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListOnceBuilt Callback Interface

public protocol SlidingSyncListOnceBuilt : AnyObject {
    func `updateList`(`list`: SlidingSyncList)  -> SlidingSyncList

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListOnceBuilt : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeUpdateList`(_ swiftCallbackInterface: SlidingSyncListOnceBuilt, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.`updateList`(
                    `list`:  try FfiConverterTypeSlidingSyncList.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterTypeSlidingSyncList.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListOnceBuilt.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListOnceBuilt
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListOnceBuilt.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListOnceBuilt: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeUpdateList`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListOnceBuilt {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsynclistoncebuilt(foreignCallbackCallbackInterfaceSlidingSyncListOnceBuilt, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListOnceBuilt>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListOnceBuilt : FfiConverter {
    typealias SwiftType = SlidingSyncListOnceBuilt
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomItemsObserver Callback Interface

public protocol SlidingSyncListRoomItemsObserver : AnyObject {
    func `didReceiveUpdate`()

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomItemsObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomItemsObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomItemsObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsynclistroomitemsobserver(foreignCallbackCallbackInterfaceSlidingSyncListRoomItemsObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomItemsObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomItemsObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomItemsObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomListObserver Callback Interface

public protocol SlidingSyncListRoomListObserver : AnyObject {
    func `didReceiveUpdate`(`diff`: SlidingSyncListRoomsListDiff)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomListObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `diff`:  try FfiConverterTypeSlidingSyncListRoomsListDiff.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomListObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomListObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsynclistroomlistobserver(foreignCallbackCallbackInterfaceSlidingSyncListRoomListObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomListObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomListObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomListObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListRoomsCountObserver Callback Interface

public protocol SlidingSyncListRoomsCountObserver : AnyObject {
    func `didReceiveUpdate`(`count`: UInt32)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListRoomsCountObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `count`:  try FfiConverterUInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListRoomsCountObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListRoomsCountObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsynclistroomscountobserver(foreignCallbackCallbackInterfaceSlidingSyncListRoomsCountObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListRoomsCountObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListRoomsCountObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListRoomsCountObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncListStateObserver Callback Interface

public protocol SlidingSyncListStateObserver : AnyObject {
    func `didReceiveUpdate`(`newState`: SlidingSyncState)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncListStateObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveUpdate`(_ swiftCallbackInterface: SlidingSyncListStateObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveUpdate`(
                    `newState`:  try FfiConverterTypeSlidingSyncState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncListStateObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncListStateObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncListStateObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncListStateObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncListStateObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsyncliststateobserver(foreignCallbackCallbackInterfaceSlidingSyncListStateObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncListStateObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncListStateObserver : FfiConverter {
    typealias SwiftType = SlidingSyncListStateObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SlidingSyncObserver Callback Interface

public protocol SlidingSyncObserver : AnyObject {
    func `didReceiveSyncUpdate`(`summary`: UpdateSummary)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSlidingSyncObserver : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeDidReceiveSyncUpdate`(_ swiftCallbackInterface: SlidingSyncObserver, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`didReceiveSyncUpdate`(
                    `summary`:  try FfiConverterTypeUpdateSummary.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSlidingSyncObserver.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SlidingSyncObserver
            do {
                cb = try FfiConverterCallbackInterfaceSlidingSyncObserver.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SlidingSyncObserver: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDidReceiveSyncUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSlidingSyncObserver {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_slidingsyncobserver(foreignCallbackCallbackInterfaceSlidingSyncObserver, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SlidingSyncObserver>()
}

extension FfiConverterCallbackInterfaceSlidingSyncObserver : FfiConverter {
    typealias SwiftType = SlidingSyncObserver
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for TimelineListener Callback Interface

public protocol TimelineListener : AnyObject {
    func `onUpdate`(`update`: TimelineDiff)

}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceTimelineListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in


    func `invokeOnUpdate`(_ swiftCallbackInterface: TimelineListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onUpdate`(
                    `update`:  try FfiConverterTypeTimelineDiff.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceTimelineListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: TimelineListener
            do {
                cb = try FfiConverterCallbackInterfaceTimelineListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("TimelineListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnUpdate`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }

        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_matrix_sdk_ffi_fn_init_callback_timelinelistener(foreignCallbackCallbackInterfaceTimelineListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<TimelineListener>()
}

extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeHomeserverLoginDetails: FfiConverterRustBuffer {
    typealias SwiftType = HomeserverLoginDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHomeserverLoginDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHomeserverLoginDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = RoomMember?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncList: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncList?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncList.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncList.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSlidingSyncRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSlidingSyncRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInReplyToDetails: FfiConverterRustBuffer {
    typealias SwiftType = InReplyToDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInReplyToDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInReplyToDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeInsertData: FfiConverterRustBuffer {
    typealias SwiftType = InsertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInsertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInsertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSubscription: FfiConverterRustBuffer {
    typealias SwiftType = RoomSubscription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSubscription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSubscription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSetData: FfiConverterRustBuffer {
    typealias SwiftType = SetData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePushFormat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePushFormat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceNotificationDelegate: FfiConverterRustBuffer {
    typealias SwiftType = NotificationDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceNotificationDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceNotificationDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceSlidingSyncObserver: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncObserver?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSlidingSyncObserver.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSlidingSyncObserver.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRequiredState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRequiredState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequiredState: FfiConverterRustBuffer {
    typealias SwiftType = [RequiredState]

    public static func write(_ value: [RequiredState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequiredState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequiredState] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequiredState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequiredState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = [UserProfile]

    public static func write(_ value: [UserProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserProfile.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRoomListEntry: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntry]

    public static func write(_ value: [RoomListEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceOptionTypeSlidingSyncRoom: FfiConverterRustBuffer {
    typealias SwiftType = [SlidingSyncRoom?]

    public static func write(_ value: [SlidingSyncRoom?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterOptionTypeSlidingSyncRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SlidingSyncRoom?] {
        let len: Int32 = try readInt(&buf)
        var seq = [SlidingSyncRoom?]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterOptionTypeSlidingSyncRoom.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeReceipt: FfiConverterRustBuffer {
    public static func write(_ value: [String: Receipt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeReceipt.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Receipt] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Receipt]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeReceipt.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `genTransactionId`()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id($0)
}
    )
}

public func `logEvent`(`file`: String, `line`: UInt32, `column`: UInt32, `level`: LogLevel, `target`: String, `message`: String)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(`file`),
        FfiConverterUInt32.lower(`line`),
        FfiConverterUInt32.lower(`column`),
        FfiConverterTypeLogLevel.lower(`level`),
        FfiConverterString.lower(`target`),
        FfiConverterString.lower(`message`), $0)
}
}



public func `mediaSourceFromUrl`(`url`: String)  -> MediaSource {
    return try!  FfiConverterTypeMediaSource.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_media_source_from_url(
        FfiConverterString.lower(`url`), $0)
}
    )
}

public func `messageEventContentFromMarkdown`(`md`: String)  -> RoomMessageEventContent {
    return try!  FfiConverterTypeRoomMessageEventContent.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(`md`), $0)
}
    )
}

public func `sdkGitSha`()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha($0)
}
    )
}

public func `setupOtlpTracing`(`filter`: String, `clientName`: String, `user`: String, `password`: String, `otlpEndpoint`: String)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_setup_otlp_tracing(
        FfiConverterString.lower(`filter`),
        FfiConverterString.lower(`clientName`),
        FfiConverterString.lower(`user`),
        FfiConverterString.lower(`password`),
        FfiConverterString.lower(`otlpEndpoint`), $0)
}
}



public func `setupTracing`(`filter`: String)  {
    try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_setup_tracing(
        FfiConverterString.lower(`filter`), $0)
}
}



private enum CheckVersionResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var checkVersionResult: CheckVersionResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return CheckVersionResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() != 65533) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_log_event() != 62033) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_media_source_from_url() != 48238) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() != 35040) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() != 11183) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_setup_otlp_tracing() != 53941) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_setup_tracing() != 13500) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() != 25195) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() != 27167) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() != 25201) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() != 3671) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_add_range() != 57863) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_current_room_count() != 28445) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_current_room_list() != 28978) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_get_timeline_limit() != 6712) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_observe_rooms_count() != 62225) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_observe_room_list() != 12987) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_observe_state() != 12538) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_reset_ranges() != 46679) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_set_range() != 48586) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_set_timeline_limit() != 43302) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclist_unset_timeline_limit() != 15719) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_avatar_url() != 37308) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_ban() != 33458) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_invite() != 27576) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_kick() != 3852) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_redact() != 19326) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_send_message() != 6558) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_send_state() != 23998) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_can_trigger_room_notification() != 15452) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_display_name() != 40871) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_ignore() != 20664) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_account_user() != 36936) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_ignored() != 32613) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_is_name_ambiguous() != 58257) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_membership() != 27982) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_normalized_power_level() != 17587) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_power_level() != 3849) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_unignore() != 56421) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommember_user_id() != 60084) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() != 53516) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() != 16627) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() != 61241) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append() != 49675) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change() != 29896) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert() != 24692) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back() != 13831) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front() != 21268) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove() != 29556) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset() != 51144) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set() != 879) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() != 44584) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() != 8330) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() != 33857) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() != 18234) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_configure_homeserver() != 39753) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_homeserver_details() != 34256) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_login() != 51598) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_authenticationservice_restore_with_access_token() != 36575) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_base_path() != 7444) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() != 44437) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() != 27083) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_passphrase() != 864) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() != 62997) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_versions() != 12312) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_proxy() != 56243) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() != 60344) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() != 3669) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_add_range() != 31001) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_filters() != 29583) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_no_filters() != 29534) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_no_timeline_limit() != 21616) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_once_built() != 52827) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_required_state() != 43471) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_reset_ranges() != 31691) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_sort() != 50198) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_sync_mode_growing() != 16525) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_sync_mode_paging() != 34951) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_sync_mode_selective() != 48936) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsynclistbuilder_timeline_limit() != 28972) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_enter() != 35904) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_exit() != 16758) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_is_none() != 36602) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_data() != 35305) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() != 10684) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() != 52464) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_create_room() != 3428) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_device_id() != 11266) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_display_name() != 60379) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() != 5600) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() != 27030) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() != 48356) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() != 56583) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_item() != 21870) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() != 43206) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() != 6860) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() != 64174) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() != 3305) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login() != 3527) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_logout() != 51260) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() != 4065) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_rooms() != 47471) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_search_users() != 46706) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_session() != 56234) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() != 6499) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() != 2687) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() != 64497) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_notification_delegate() != 21033) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() != 46648) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync() != 26936) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() != 735) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() != 62456) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id() != 26690) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_content() != 48593) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_debug_info() != 24252) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_event_id() != 31946) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_editable() != 29058) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_local() != 64224) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_own() != 42462) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_is_remote() != 38329) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_local_send_state() != 19154) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_reactions() != 21306) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_read_receipts() != 26610) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_sender() != 1665) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_sender_profile() != 21623) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_timestamp() != 40228) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_eventtimelineitem_unique_identifier() != 18285) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_authentication_issuer() != 37548) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() != 25425) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() != 40876) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() != 34298) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_body() != 36716) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_in_reply_to() != 25801) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_is_edited() != 20497) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_message_msgtype() != 52820) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_accept_invitation() != 1594) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() != 26328) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_add_timeline_listener() != 28483) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() != 41766) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() != 52388) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() != 17770) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_display_name() != 48839) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_edit() != 64955) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_fetch_details_for_event() != 8095) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_fetch_members() != 28806) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_id() != 12308) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() != 7010) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() != 52986) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_inviter() != 9854) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() != 62895) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() != 53633) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() != 5068) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_public() != 42254) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_space() != 8388) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned() != 8174) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() != 29103) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_leave() != 32484) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member() != 63311) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members() != 28201) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_membership() != 62963) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() != 26534) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() != 41512) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_name() != 51510) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_paginate_backwards() != 54167) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_redact() != 53363) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_reject_invitation() != 63670) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() != 30371) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_timeline() != 7024) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_report_content() != 45879) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_retry_decryption() != 17743) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send() != 60271) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_audio() != 44590) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_file() != 18466) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_image() != 8885) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_reaction() != 21324) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_read_marker() != 47462) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_read_receipt() != 16822) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_reply() != 28386) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_video() != 33883) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_name() != 35415) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() != 9114) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_topic() != 55526) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() != 17140) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() != 46152) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() != 8903) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() != 29945) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_is_verified() != 35678) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_verification() != 3645) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() != 52241) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() != 22085) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_add_cached_list() != 57064) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_add_common_extensions() != 62767) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_add_list() != 41315) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_get_room() != 60249) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_get_rooms() != 19799) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_reset_lists() != 54195) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_set_observer() != 53265) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_subscribe_to_room() != 48253) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_sync() != 20224) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsync_unsubscribe_from_room() != 58275) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_add_cached_list() != 49932) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_add_list() != 61859) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_build() != 65391) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_bump_event_types() != 65312) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_homeserver() != 62399) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_storage_key() != 49501) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_without_account_data_extension() != 2317) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_without_e2ee_extension() != 52211) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_without_receipt_extension() != 25777) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_without_to_device_extension() != 17246) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_without_typing_extension() != 43128) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_with_all_extensions() != 40377) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncbuilder_with_common_extensions() != 65139) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_add_timeline_listener() != 32754) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_avatar_url() != 47248) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_full_room() != 32352) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_has_unread_notifications() != 35130) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_is_dm() != 38395) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_is_initial() != 63464) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_latest_room_message() != 23437) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_name() != 24035) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_room_id() != 37051) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_subscribe_to_room() != 28121) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_unread_notifications() != 44389) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_slidingsyncroom_unsubscribe_from_room() != 47022) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() != 3024) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() != 56466) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitemcontent_as_message() != 21743) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitemcontent_kind() != 61737) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() != 17684) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() != 15002) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() != 52564) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() != 36478) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_authenticationservice_new() != 51213) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() != 54066) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_slidingsynclistbuilder_new() != 14792) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_current() != 63785) {
        return CheckVersionResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_new() != 43592) {
        return CheckVersionResult.apiChecksumMismatch
    }
    return CheckVersionResult.ok
}

private func uniffiCheckFfiVersionMismatch() {
    switch checkVersionResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
